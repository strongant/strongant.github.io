[{"title":"Spring Security哈希认证记住我例子","date":"2017-11-16T16:19:00.000Z","path":"2017/11/17/Spring-Security哈希认证记住我例子/","text":"在本教程中，我们将演示如何使用Spring Security 创建通过哈希认证记住我的应用程序。请记住，身份验证是一项功能，它允许网站在会话之间记住用户的身份。Spring Security提供了两种记住我的实现。一种使用哈希来保存基于cookie的令牌的安全性，我们将在本教程中解决这个问题。第二种是使用数据库或其他永久存储机制来存储生成的令牌。 基于哈希令牌的方法记住我当用户启用记住我的身份验证时，会创建一个cookie并在后续登录时传递。这种方法使用散列来实现一个有用的记住我策略。该cookie的组成如下： 1234567base64(username + &quot;:&quot; + expirationTime + &quot;:&quot; +md5Hex(username + &quot;:&quot; + expirationTime + &quot;:&quot; password + &quot;:&quot; + key))username: As identifiable to the UserDetailsServicepassword: That matches the one in the retrieved UserDetailsexpirationTime: The date and time when the remember-me token expires, expressed in millisecondskey: A private key to prevent modification of the remember-me token 注意：记住我的记号只对指定的expirationTime和有效的username，password并且key不会改变。警告：这是一个潜在的安全问题。当记住我的令牌被恶意的用户代理捕获时，这个用户代理能够使用令牌直到它到期。如果需要更好的安全性，你应该使用这种persistent remember-me token方法。 项目结构我们先看看项目结构。 Maven的依赖我们使用Apache Maven来管理我们的项目依赖关系。确保以下依赖存在类路径中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.memorynotfound.spring.security&lt;/groupId&gt; &lt;artifactId&gt;hashing-remember-me&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;url&gt;https://memorynotfound.com&lt;/url&gt; &lt;name&gt;Spring Security - $&#123;project.artifactId&#125;&lt;/name&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- bootstrap and jquery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;3.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- testing --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Spring Security记住我哈希认证配置要想使记住我散列认证配置可用，我们需要在Spring中注册。在下一节中，我们将演示Java和XML配置。 SPRING JAVA配置在这里，我们正使用Java代码的方式配置记住我身份认证的配置。通过扩展我们的Spring配置类WebSecurityConfigurerAdapter，我们可以简单地配置记住我的身份验证configure(HttpSecurity http)方法。我们需要配置一个安全和唯一的密钥。这个密钥通常是一个强大而独特的密码。我们可以随意配置“记住我”cookie名称并设置令牌有效期。默认为2周。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.memorynotfound.spring.security.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.web.util.matcher.AntPathRequestMatcher;// 使用注解方式配置SpringSecurity记住我配置时，开启此注解@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring() .antMatchers( &quot;/js/**&quot;, &quot;/css/**&quot;, &quot;/img/**&quot;, &quot;/webjars/**&quot;); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login&quot;) .permitAll() .and() .logout() .invalidateHttpSession(true) .clearAuthentication(true) .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;)) .logoutSuccessUrl(&quot;/login?logout&quot;) .permitAll() .and() .rememberMe() .key(&quot;unique-and-secret&quot;) .rememberMeCookieName(&quot;remember-me-cookie-name&quot;) .tokenValiditySeconds(24 * 60 * 60); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication().withUser(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;); &#125;&#125; SPRING XML配置该文件spring-security-config.xml位于src/main/resources/文件夹中，是等效的Spring XML配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans:beans xmlns=&quot;http://www.springframework.org/schema/security&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;http&gt; &lt;intercept-url pattern=&quot;/login&quot; access=&quot;permitAll()&quot;/&gt; &lt;intercept-url pattern=&quot;/js/**&quot; access=&quot;permitAll()&quot;/&gt; &lt;intercept-url pattern=&quot;/css/**&quot; access=&quot;permitAll()&quot;/&gt; &lt;intercept-url pattern=&quot;/img/**&quot; access=&quot;permitAll()&quot;/&gt; &lt;intercept-url pattern=&quot;/webjars/**&quot; access=&quot;permitAll()&quot;/&gt; &lt;intercept-url pattern=&quot;/**&quot; access=&quot;isAuthenticated()&quot;/&gt; &lt;!--Spring Security 4.0以后默认开启宽展请求伪造保护，这里配置禁用，不安全的操作。--&gt; &lt;csrf disabled=&quot;true&quot;/&gt; &lt;form-login login-page=&quot;/login&quot;/&gt; &lt;logout invalidate-session=&quot;true&quot; logout-url=&quot;/logout&quot; logout-success-url=&quot;/login?logout&quot;/&gt; &lt;remember-me key=&quot;unique-and-secret&quot; remember-me-cookie=&quot;remember-me-cookie-name&quot; token-validity-seconds=&quot;86400&quot;/&gt; &lt;/http&gt; &lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;user-service&gt; &lt;user name=&quot;user&quot; password=&quot;password&quot; authorities=&quot;ROLE_USER&quot; /&gt; &lt;/user-service&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt;&lt;/beans:beans&gt; 创建控制器我们创建了一些简单的导航控制器 123456789101112131415161718package com.memorynotfound.spring.security.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class HomeController &#123; @GetMapping(&quot;/&quot;) public String greeting()&#123; return &quot;index&quot;; &#125; @GetMapping(&quot;/login&quot;) public String login() &#123; return &quot;login&quot;; &#125;&#125; 启动Spring我们使用Spring Boot来启动我们的应用程序。 123456789101112131415package com.memorynotfound.spring.security;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication// uncomment if you want to use Spring Security XML Configuration// 当使用xml的方式配置时，开启此注解注释掉Java代码方式的配置// @ImportResource(&quot;classpath:spring-security-config.xml&quot;)public class Run &#123; public static void main(String[] args) &#123; SpringApplication.run(Run.class, args); &#125;&#125; Thymeleaf模板我们用Thymeleaf来创建我们的视图。这些模板使用bootstrap和jquery，它们从org.webjars中加载。 创建登录页面该login.html页面位于该src/main/resources/templates文件夹中。在表单中我们创建了一个remember-me复选框。当用户启用记住我的身份验证时，cookie会传递给浏览器，该浏览器将以指定的时间到期。当用户在会话之间访问页面时，Spring Security会使用基于记住我的token自动认证。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/webjars/bootstrap/3.3.7/css/bootstrap.min.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/css/main.css&#125;&quot;/&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;h3&gt;&lt;i class=&quot;glyphicon glyphicon-lock&quot; style=&quot;font-size:2em;&quot;&gt;&lt;/i&gt;&lt;/h3&gt; &lt;h2 class=&quot;text-center&quot;&gt;Login&lt;/h2&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;div th:if=&quot;$&#123;param.error&#125;&quot;&gt; &lt;div class=&quot;alert alert-danger&quot;&gt; Invalid username or password. &lt;/div&gt; &lt;/div&gt; &lt;div th:if=&quot;$&#123;param.logout&#125;&quot;&gt; &lt;div class=&quot;alert alert-info&quot;&gt; You have been logged out. &lt;/div&gt; &lt;/div&gt; &lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt; &lt;input id=&quot;username&quot; name=&quot;username&quot; autofocus=&quot;autofocus&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt; &lt;i class=&quot;glyphicon glyphicon-lock&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; type=&quot;password&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt; &lt;input id=&quot;remember-me&quot; name=&quot;remember-me&quot; type=&quot;checkbox&quot;/&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success btn-block&quot;&gt;Login&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/webjars/jquery/3.2.1/jquery.min.js/&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/webjars/bootstrap/3.3.7/js/bootstrap.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建一个安全的页面该index.html页面位于src/main/resources/templates目录中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/webjars/bootstrap/3.3.7/css/bootstrap.min.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/css/main.css&#125;&quot;/&gt; &lt;title&gt;Registration&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;h1&gt;Spring Security Remember Me Hashing Configuration Example&lt;/h1&gt; &lt;div sec:authorize=&quot;isRememberMe()&quot;&gt; The user: &lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; is logged in by &quot;Remember Me Cookies&quot;. &lt;/div&gt; &lt;div sec:authorize=&quot;isFullyAuthenticated()&quot;&gt; The user: &lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; is logged in by &quot;Username / Password&quot;. &lt;/div&gt;&lt;/div&gt;&lt;footer&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt; &amp;copy; Memorynotfound.com &lt;span sec:authorize=&quot;isAuthenticated()&quot; style=&quot;display: inline-block;&quot;&gt; | Logged user: &lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; | Roles: &lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt; | &lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;Sign Out&lt;/a&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/footer&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/webjars/jquery/3.2.1/jquery.min.js/&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/webjars/bootstrap/3.3.7/js/bootstrap.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 演示访问http://localhost:8080和页面被重定向到http://localhost:8080/login。 当用户和密码填写正确后，页面被重定向到http://localhost:8080/。 当检查我们的应用程序的cookie时，我们可以看到Spring创建了我们之前配置的remember-me-cookie-namecookie。 当您删除JSESSIONIDCookie并刷新页面时，当”remember-me“Cookie未过期时，您将自动登录。 参考 Spring Security Remember Me Documentation WebSecurityConfigurerAdapter JavaDoc RememberMeConfigurer JavaDoc 下载下载它 - spring-security-remember-me-hashing-authentication-configuration-example 原文链接：https://memorynotfound.com/spring-security-remember-hashing-authentication-example/","tags":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://baiwenhui.com/tags/SpringSecurity/"}]},{"title":"一行命令导入项目到IDEA","date":"2017-11-12T05:11:00.000Z","path":"2017/11/12/一行命令导入项目到IDEA/","text":"如何使用一行命令打开一个zip文件并导入项目到IDEA方法如下首先你得有我上次分享的那个idea打开项目的shell脚本。 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/sh# check for where the latest version of IDEA is installedIDEA=`ls -1d /Applications/IntelliJ\\ * | tail -n1`wd=`pwd`# were we given a directory?if [ -d &quot;$1&quot; ]; then# echo &quot;checking for things in the working dir given&quot; wd=`ls -1d &quot;$1&quot; | head -n1`fi# were we given a file?if [ -f &quot;$1&quot; ]; then# echo &quot;opening &apos;$1&apos;&quot; open -a &quot;$IDEA&quot; &quot;$1&quot;else # let&apos;s check for stuff in our working directory. pushd $wd &gt; /dev/null # does our working dir have an .idea directory? if [ -d &quot;.idea&quot; ]; then# echo &quot;opening via the .idea dir&quot; open -a &quot;$IDEA&quot; . # is there an IDEA project file? elif [ -f *.ipr ]; then# echo &quot;opening via the project file&quot; open -a &quot;$IDEA&quot; `ls -1d *.ipr | head -n1` # Is there a pom.xml? elif [ -f pom.xml ]; then# echo &quot;importing from pom&quot; open -a &quot;$IDEA&quot; &quot;pom.xml&quot; # can&apos;t do anything smart; just open IDEA else# echo &apos;cbf&apos; open &quot;$IDEA&quot; fi popd &gt; /dev/nullfi 然后使用如下脚本即可： 123456789101112fullFileName=$1suffix=$&#123;fullFileName#*.&#125;if [ &quot;$suffix&quot; != &quot;zip&quot; ];then echo &quot;Must be a valid zip file&quot;else filename=$&#123;fullFileName%.*&#125; echo &quot;filename: $filename&quot; echo &quot;now unzip $1 and use idea $1&quot; unzip $1 &amp;&amp; idea $filenamefi 将此脚本另存为uao.sh ， 放在合适的位置，然后建立一个软链，这里我把它放在此处/usr/local/bin/uao.sh，建立一个软链接ln -sf /usr/local/bin/uao.sh /usr/local/bin/uao。以后如果要将zip文件解压，打开idea，导入项目到idea这三个操作，直接使用这个脚本一行命令一步即可完成。赶快试试吧！","tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://baiwenhui.com/tags/IDEA/"}]},{"title":"使用淘宝镜像加速electron的下载","date":"2017-10-29T15:07:00.000Z","path":"2017/10/29/使用淘宝镜像加速electron的下载/","text":"目前github开源的electron库被好多桌面端应用广泛使用，有时候我们安装这类应用时特别慢，原因就是卡在了下载electron压缩包这个阶段，速度奇慢。为了不浪费我们宝贵的时间，使用下面的脚本可以帮助你分分钟下载成功electron，感谢淘宝npm镜像。 1export ELECTRON_MIRROR=\"https://npm.taobao.org/mirrors/electron/\"","tags":[{"name":"electron","slug":"electron","permalink":"http://baiwenhui.com/tags/electron/"}]},{"title":"groovy中的each坑小记","date":"2017-10-26T07:29:00.000Z","path":"2017/10/26/groovy中的each坑小记/","text":"前言Java编程中，如果要跳出for循环，直接使用break即可。但是在groovy的each方法中，如果使用break，则程序在运行时就会报如下错误：the break statement is only allowed inside loops or switches。 如何跳出each循环呢？ groovy的each方法是一个闭包操作，如果想跳出循环，则可以使用return true。 但是存在一个问题：就是这里的return true并不完全等价于java for循环中的break操作。它更像是java for循环中的continue操作，跳出当前循环，继续下一次循环。至于这里的原因，有待研究。 诡异的产生 当使用“==”操作符号进行比较时，return true等价于java for循环中的continue，但如果是“&gt;=” 操作符的话，等价于java for循环中的break操作。测试代码如下： 1234567891011121314151617181920212223def a = [1, 2, 3, 4]println &quot;each loop break use groovy&quot;a.each &#123; // groovy each 循环中的return true类似于java for循环中的continue // 当遍历的元素等于2时，跳过当前元素，继续执行, 如果写&gt;= 时，的确也等价于break if (it &gt;= 2) return true // break println it // do the stuff that you wanted to before break&#125;println &quot;for loop break use java&quot;for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] == 2) &#123; // java for 循环中的break直接跳出当前循环 // 当遍历的元素等于2时，直接跳出循环 break &#125; println a[i]&#125; 这便是groovy中的each闭包方法的诡异之处，奇怪的是，如果你对集合元素使用find方法遍历，当比较操作符是“==”时，并不会发生以上的问题，测试代码如下：1234567def a = [1, 2, 3, 4, 5, 6, 7]a.find &#123; if (it == 3) return true // break 此时的break等价于java for循环中的break println it return false // 继续循环&#125; 建议 当对遍历的元素进行迭代，并且在迭代的过程中需要跳出当前循环的，推荐使用groovy的find方法或者使用java的for循环，不要使用groovy的each方法，这样就可以保证流程控制没有错误。","tags":[{"name":"groovy","slug":"groovy","permalink":"http://baiwenhui.com/tags/groovy/"}]},{"title":"Mac下使用jenvs安装Java9","date":"2017-10-23T08:36:00.000Z","path":"2017/10/23/Mac下使用jenvs安装Java9/","text":"JDK9已经距离现在发布了好一段时间了，如果你还没有尝试一下，建议安装体验体验！一般情况下，我们的PC上基本都会安装多个版本的JDK，此时我们为了多个JDK版本的切换，这里，强烈推荐使用jenvs,关于具体使用请参考作者的详细介绍。这里不多做介绍。 已经安装了jenvs的同学，则跳过上面的内容，直接看下面内容–如何将JDK9添加到jenvs的管理中。 1.下载JDK9 2.安装完毕后，只需要打开终端做如下操作即可（jdk9安装完毕后，默认在mac系统的/Library/Java/JavaVirtualMachines/）：1jenv add /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home 3.以上操作执行完毕后，会得到如下提示：123oracle64-9.0.1 added9.0.1 added9.0 added 4.切换Java91jenv shell 9.0.1 5.此时我们便可以使用jenv进行切换，尝试使用java9的新特性了！","tags":[{"name":"jdk","slug":"jdk","permalink":"http://baiwenhui.com/tags/jdk/"},{"name":"java","slug":"java","permalink":"http://baiwenhui.com/tags/java/"}]},{"title":"阿里巴巴Java开发规约的IDEA插件使用","date":"2017-10-16T01:21:00.000Z","path":"2017/10/16/阿里巴巴Java开发规约的IDEA插件使用/","text":"作者：不想当码农的程序员 原文：http://www.jianshu.com/p/2f271e6d675c编辑：Moon 就在10月15日上午9：00，阿里巴巴在杭州云栖大会《研发效能峰会》上，正式发布《阿里巴巴Java开发手册》扫描插件，该插件在扫描代码后，将不符合《手册》的代码按 Blocker/ Critical/ Major三个等级显示在下方，甚至在IDEA上，还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能。 Git地址为：https://github.com/alibaba/p3c IDea的安装方式：IDEA版的插件发布到了IDEA官方仓库中(最低支持版本14.1.7，JDK1.7+)，只需打开 1Settings &gt;&gt; Plugins &gt;&gt; Browse repositories 输入 Alibaba 搜索一下便可以看到对应插件了，点击安装等待安装完成。 如图: 这里写图片描述 Eclipse的安装方式：Eclipse版插件支持4.2（Juno，JDK1.8+）及以上版本，提供Update Site，通过 1Help &gt;&gt; Install New Software 然后输入 https://p3c.alibaba.com/plugin/eclipse/update即可看到安装列表，安装即可。 插件的更新，可以通过 Help&gt;&gt;CheckforUdates 进行新版本检测。 怎么用呵呵 右键，，看图 – 还有自动提示的效果 可以说是非常棒了 推荐阅读 程序员你为什么这么累【续】：如何应对需求变更 Spring4All社区正式招募Spring Guides翻译小分队~ 海外IT工程师工作福利揭秘 一个不可思议的MySQL慢查分析与解决 都在说微服务，那么微服务的反模式和陷阱是什么 长按指纹 一键关注","tags":[{"name":"工具","slug":"工具","permalink":"http://baiwenhui.com/tags/工具/"}]},{"title":"Spring官方周报20171003","date":"2017-10-09T12:41:00.000Z","path":"2017/10/09/Spring官方周报20171003/","text":"@strongant &amp; @chenzhijun &amp; @maskwang 翻译 欢迎收看新一期 《Spring 周报》！周报包含了上周的很多内容，可以了解非常多的干货。现在 Spring Framework 5.0 已推出！Spring Framework 5.0 同时也带来了许多发行版本，在本文中你会知道有哪些版本。另外，本周我(Josh Long)和其他来自Pivotal和Spring的团队成员，都会出席JavaOne大会，希望您能来我们的展位找我们或者和我们一起参与讨论。 https://spring.io/blog/2017/09/28/pivotal-and-spring-team-at-javaone-2017 以下是关于周报的内容： 上周，我研究了一下怎么使用 Spring Framwork5 来构建基于 websocket 的响应式应用: https://spring.io/blog/2017/09/27/spring-tips-reactive-websockets-with-spring-framework-5 Spring AMQP 和 Spring Integration 开发组领导 Gary Russell 宣布发布 Spring AMQP 2.0.RC2: https://spring.io/blog/2017/09/27/spring-amqp-2-0-release-candidate-2-available 经过一段长的时间，Spring Framework 5.0.GA现在终于发布了！新版本集成了 Reactor 项目，包括响应式 web 运行时环境，Kotlin 扩展，以及全面基于 Java EE 7 和 Java 8。新的发行版包含了太多的新东西,如果想要知道更多的消息，查看版本说明，然后查看更新内容: https://spring.io/blog/2017/09/28/spring-framework-5-0-goes-ga https://github.com/spring-projects/spring-framework/wiki/What&#39;s-New-in-the-Spring-Framework#whats-new-in-spring-framework-5x Spring Reactor 团队成员 Simon Baslé 宣布发布 Spring 和 Reactor 集成的新版本Reactor Bismuth。这个版本为 Spring Framework 5.0 奠定了基础，它自己本身也包含了非常多的功能: https://spring.io/blog/2017/09/28/reactor-bismuth-is-out Spring Framework 5.0 版本更新了一些其他的项目，其中包括发布了 Spring Data Kay。自从 Spring Data 于2009年成立以来，这是 Spring Data 更新的最大版本！该新版本以 Spring Framework 5.0 ，Java 8 和 Java EE 7 作为基准。它包括一个改进的仓储(repository) API（完整支持Optional&lt;T&gt;），支持响应式数据访问（Cassandra，Couchbase，MongoDB和Redis），新发布版本新增 Spring Data Geode，使用非空注解并且优化了运行时检查空注解，通过 Kotlin 构造方法，支持 Kotlin 的 null安全和不可变数据类，支持兼容 Java 9，如果想了解更多请看 Spring Data Kay 文档: https://spring.io/blog/2017/10/02/spring-data-release-train-kay-goes-ga Spring 消息中间件团队成员 Artem Bilan 宣布发布 Spring for Apache Kafka 2.0.GA。新版本包括支持 Apache Kafka，支持事务，消息头匹配，Apache Kafka 的Streams 支持，新的 KafkaAdmin，增加 @KafkaListener 和 Consumer 错误处理和群组支持的方案。它还支持使用 @EmbeddedKafka 进行测试: https://spring.io/blog/2017/10/02/spring-for-apache-kafka-2-0-ga-available Spring Cloud 团队成员 Ryan Baxter 宣布发布 Spring Cloud Dalston SR4。新版本更新了 Spring Cloud Contract，Spring Cloud Config，Spring Cloud Commons，Spring Cloud Netflix和Spring Cloud Sleuth: https://spring.io/blog/2017/10/03/spring-cloud-dalston-sr4-is-now-available Spring REST Docs 开发领导者 Andy Wilkinson 宣布发布 Spring REST Docs 1.2.2.RELEASE 。这个维护版本包括一些错误修复和文档的改进，推荐大家升级: https://spring.io/blog/2017/09/28/spring-rest-docs-1-2-2-release 查看 Spring Framework 5 的全新的通过构造方法实现注解的实现: https://github.com/spring-projects/spring-framework/commit/23497a7ece7aac1591187b46f4b601d2f48764e0 德语访谈中 Andreas Falk 提到的 Spring Framework 5.0 和 Spring Security 5.0 中的新功能: https://jaxenter.de/spring-security-interview-falk-62685 由 Zoltan Altfatter 发表的这篇文章介绍了如何在 Spring Integration 流程中引入一个新的JMS消息来启动 Spring Batch 作业: http://blog.mimacom.com/blog/2017/09/29/trigger-a-spring-batch-job-with-a-jms-message/ Rohit Kelapure: 为什么 Pivotal 公司的 Cloud Foundry 是运行 Spring Boot 应用程序的最佳选择？ https://twitter.com/rkela/status/914924780373073920 在这篇文章中，Cristina Negrean 介绍了如何使用 Spring Cloud Data Flow 进行实时分析： https://cristinanegrean.github.io/2017/10/01/spring-cloud-dataflow-for-real-time-analytics-with-twitter-api Gabriela Motroc 在 JAXEnter 网上发布了一篇关于 Spring Framework 5 的新文章。非常多的功能都在文章包含了: https://jaxenter.com/spring-framework-5-0-137677.html Aboullaite Mohammed：使用 Elasticsearch 和 Kibana 和 Spring Boot 集合来监控一些指标: https://aboullaite.me/spring-boot-elastic-kibana/ Ordina JWorks：使用 Spring Cloud 来对微服务进行安全防护: https://ordina-jworks.github.io/microservices/2017/09/26/Secure-your-architecture-part1.html","tags":[{"name":"Spring官方周报翻译","slug":"Spring官方周报翻译","permalink":"http://baiwenhui.com/tags/Spring官方周报翻译/"}]},{"title":"Grails中序列化json出现异常数据","date":"2017-09-29T09:24:00.000Z","path":"2017/09/29/Grails中序列化json出现异常数据-md/","text":"Httpbuilder 是一个基于groovy简单的HTTP客户端工具。它基本支持常用的几种HTTP请求方式(GET,PUT,POST,DELETE,HEAD,PATCH)。 发生解析url值异常项目环境：| Grails Version: 3.0.7| Groovy Version: 2.4.4| JVM Version: 1.8.0_121 由于是使用post方式给对方推送数据，所以我们先模拟一个请求服务，使用grails快速创建一个项目，然后编写一个方法，用于处理post请求，在后端输出接收到的具体数据是什么。步骤如下： 1.进入我的目录/Users/bwh/study/grails 生成一个grails的项目1cd /Users/bwh/study/grails &amp;&amp; cd $_ &amp;&amp; grails create-app test111 使用grails脚手架生成项目，如果没有产生其他异常，一般情况下我们会得到如下提示：1| Application created at /Users/bwh/study/grails/test111 2.进入刚才生成的项目中，由于本地已经使用了8080端口，修改grails项目的默认端口：在/Users/bwh/study/grails/test111/grails-app/conf/application.yml 修改默认的8080端口，修改如下123456---...# 修改项目默认端口8080为7070server: port: 7799... 3.打开项目，在当前项目的controllers目录下新建一个测试Controller，暂时叫做TestController，使用如下脚本进行生成相应的Controller文件，其当前目录结构如下：1234567891011121314...├── grails-app│ ├── assets│ │ ├── images│ │ ├── javascripts│ │ └── stylesheets│ ├── conf│ │ ├── application.yml│ │ ├── logback.groovy│ │ └── spring│ ├── controllers│ │ ├── TestController.groovy│ │ └── UrlMappings.groovy... 4.还原现场,在刚才新建的TestController中添加此方法，用于接收对方传递过来的数据：1234567def postReport() &#123; println params def jsonObject = request.JSON println &quot;jsonObject: $&#123;jsonObject&#125;&quot; println &quot;jsonObject String: $&#123;jsonObject as JSON&#125;&quot; render([code: 10000, msg: &quot;测试获取数据!&quot;, data: params] as grails.converters.JSON) &#125; 5.启动项目1grails run-app 用于接收post请求的测试服务已经启动完毕，接下来修改响应的推送地址进行发送数据即可。相关测试代码：1234567891011121314151617#Test.groovyimport groovyx.net.http.ContentTypeimport groovyx.net.http.HTTPBuilderimport static groovyx.net.http.Method.POSTdef baseURL = &quot;http://localhost:7799/test/postReport&quot;def data = [&quot;url&quot;: &quot;http://$&#123;baseURL&#125;/test/postReport&quot;]def client = new HTTPBuilder(baseURL)client.request(POST, ContentType.JSON) &#123; body = data response.success = &#123; resp, json -&gt; println &quot;resp: $&#123;resp&#125;&quot; println &quot;success data: $&#123;json&#125;&quot; &#125; response.failure = &#123; resp, json -&gt; println &quot;resp:$&#123;resp&#125;&quot; println &quot;failure data: $&#123;json&#125;&quot; &#125;&#125; 运行测试代码后，发现测试服务端收到如下结果： 1jsonObject String: &#123;&quot;url&quot;:&#123;&quot;valueCount&quot;:1,&quot;strings&quot;:[&quot;http://&quot;,&quot;/test/postReport&quot;],&quot;bytes&quot;:[104,116,116,112,58,47,47,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,55,55,57,57,47,116,101,115,116,47,112,111,115,116,82,101,112,111,114,116,47,116,101,115,116,47,112,111,115,116,82,101,112,111,114,116],&quot;values&quot;:[&quot;http://localhost:7799/test/postReport&quot;]&#125;&#125; 可以发现url是被转换成一个字符数组了，为什么呢？通过跟踪源码，发现它的body数据构造位于此方法：123456789101112131415protected Object doRequest( URI uri, Method method, Object contentType, Closure configClosure ) throws ClientProtocolException, IOException &#123; HttpRequestBase reqMethod; try &#123; reqMethod = method.getRequestType().newInstance(); // this exception should reasonably never occur: &#125; catch ( Exception e ) &#123; throw new RuntimeException( e ); &#125; reqMethod.setURI( uri ); RequestConfigDelegate delegate = new RequestConfigDelegate( reqMethod, contentType, this.defaultRequestHeaders, this.defaultResponseHandlers ); configClosure.setDelegate( delegate ); configClosure.setResolveStrategy( Closure.DELEGATE_FIRST ); configClosure.call( reqMethod ); return this.doRequest( delegate ); &#125; 其中函数执行到configClosure.call( reqMethod )方法时，其代理对象的body值为GStringImpl对象。由此可以判断，对map中的对象类型数据没有进行转换，因此出现了以上问题。 解决办法，使用groovy自带的json序列化类JsonBuilder进行将map对象先序列化成字符串然后再传递即可。修改后测试代码如下：12345678910111213141516171819import groovy.json.JsonBuilderimport groovyx.net.http.ContentTypeimport groovyx.net.http.HTTPBuilderimport static groovyx.net.http.Method.POSTdef baseURL = &quot;http://localhost:7799/test/postReport&quot;def data = [&quot;link&quot;: &quot;http://$&#123;baseURL&#125;/test/postReport&quot;]def dataString = new JsonBuilder(data).toString()def client = new HTTPBuilder(baseURL)client.request(POST, ContentType.JSON) &#123; body = dataString response.success = &#123; resp, json -&gt; println &quot;resp: $&#123;resp&#125;&quot; println &quot;success data: $&#123;json&#125;&quot; &#125; response.failure = &#123; resp, json -&gt; println &quot;resp:$&#123;resp&#125;&quot; println &quot;failure data: $&#123;json&#125;&quot; &#125;&#125;","tags":[{"name":"grails, JsonBuilder","slug":"grails-JsonBuilder","permalink":"http://baiwenhui.com/tags/grails-JsonBuilder/"}]},{"title":"Spring官方周报20170926","date":"2017-09-27T13:45:00.000Z","path":"2017/09/27/Spring官方周报20170926/","text":"strongant &amp; maskwang 翻译嗨,亲爱的Spring粉丝们！又是一个疯狂美妙的一周！我回到旧金山，与客户和当地合作伙伴谈论关于Pivotal相关的所有事情，同时在旧金山的阳光下享受玩Java 9的乐趣。我非常喜欢，并期待着这个新的版本，当然，Spring Framework 5是开箱即用的，它使用了Java 9。 https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6 1: Spring IO平台领导Andy Wilkinson刚刚宣布了Spring IO Platform Brussels SR5。新版本包括Spring AMQP 1.7.4，Spring Boot 1.5.7，Spring Data Ingalls SR7，Spring Framework 4.3.11，Spring Integration 4.3.12，Spring Loaded 1.2.8和Spring Web Flow 2.4.6。在这个新版本中，很多东西是这样的，所以现在就开始吧！ https://spring.io/blog/2017/09/19/spring-io-platform-brussels-sr5 2: Spring工具套件主管Martin Lippert刚刚发布了在MacOS High Sierra 10.13上运行STS时如何避免一些问题。 https://spring.io/blog/2017/09/21/how-to-get-sts-eclipse-running-on-macos-high-sierra-10-13 3: Spring Cloud Task 的领导 Michael Minella刚刚宣布了Spring Cloud Task 1.2.2.RELEASE。新版本增加了对Spring Framework最近对使用MySQL的序列表的除MYISAM之外的数据库引擎的支持。 https://spring.io/blog/2017/09/25/spring-cloud-task-1-2-2-release-is-now-available 4: 经典的Spring PetClinic多年来发生了很大变化！该版本演示了与Spring和Kotlin的PetClinic。如果你曾经看过任何一个原始的PetClinics（其中许多早于Spring本身！），你会觉得这是一个非常简洁的小应用程序， https://github.com/spring-petclinic/spring-petclinic-kotlin 5: 想了解Spring Boot的功能？这份分析报告可能是指南清单！ https://content.pivotal.io/analyst-reports/spring-boot-simplifies-end-to-end-development?_lrsc=7c3f3dc7-c1fa-4e7b-863f-615b5abb2c52 6: Spring Cloud Pipelines 现在也支持Kubernetes http://cloud.spring.io/spring-cloud-pipelines/multi/multi_jenkins-pipeline-k8s.html#_connecting_to_a_kubo_cluster 7: Oracle发布Java 9！这是一个很大的事情！在Java 9中有很多好处。如果不使用Java 9，请尝试一下Spring Framework 5，Spring Framework 5在Java 9（模块和类路径）上运行，没有任何问题。 https://www.infoq.com/news/2017/09/Java-9-release-sept-21 8: Twitter上的Alex Falappa发表：“下一个牛逼的SpringBoot插件：用于检测和修复丢失的pom依赖关系的java编辑器提示https://t.co/n7w22q4sMK” https://twitter.com/aless_falappa/status/912735050093010944 9: 最近有人询问有关在Cloud Foundry的Spring Boot应用程序中演示mTLS身份验证的示例。我不知道，所以 - 我经常这样做 - 我问Spring Security的主管Rob Winch，他分享了Java Cloud Foundry经验领导Ben Hale这个惊人的例子。很有意思！ https://github.com/nebhale/mtls-sample 10: 我喜欢这个博客关于Pivotal领域的首席技术官Josh McKenty和他所在的云和云构建 https://www.youtube.com/watch?v=OfwDTYeqHcI 11: 新的RebelLabs开发人员生产力报告已经出炉，并显示出Spring持续强劲增长。 Spring有众多用户，占46％，而Java EE则占33％。它也显示了Java 8的惊人增长，72％的用户使用它。哈哈，这两个好消息！ https://zeroturnaround.com/rebellabs/developer-productivity-report-2017-why-do-you-use-java-tools-you-use/ 12: 新的Microsoft和新的Microsoft SQL Server 2017版本在这里，它运行在Linux上！我从来没有想过我会看到这一天。这与Spring有什么关系？绝对没有。只是..它真的很酷！ https://arstechnica.com/gadgets/2017/09/microsoft-ignite-2017-azure-sql/?amp=1 13: 您在Spring Framework 5的功能Web框架中看到了7月份的活动中Spring大牛Arjen Poutsma的网络研讨会的成果？ https://www.brighttalk.com/webcast/14893/263393?_lrsc=b02b5b66-1acb-44bc-8a09-1f23cdc47bf2 14: 说到响应式，你也可以欣赏Evgeny Poberezkin关于响应式编程演变的这个演讲。 https://www.infoq.com/presentations/reactive-programming-evolution 15: Oracle有一个很好的选择了一些内容，引入了Java 9中的新功能。看看吧！ https://www.oracle.com/java/java9-screencasts.html 16: Spring社区朋友迈克尔·西蒙斯（Michael Simons）介绍了Spring Boot的新版德语书籍。快去一探究竟！ https://www.amazon.de/dp/3864905257/ref=cm_sw_r_tw_api_1.zXzbGMMWCEC 17: 最新版本的Camunda BPM系统具有Spring Boot集成功能。 https://github.com/camunda/camunda-bpm-spring-boot-starter/ 18: .NET大牛Richard Seroter表示，Java和Spring Cloud用户对如下会觉得无趣：学习如何使用Pivotal的Steeltoe框架将断路器集成到.NET应用程序中。 https://seroter.wordpress.com/2017/09/21/adding-circuit-breakers-to-your-net-applications/amp/ 19: 织机系统将Pivotal Cloud Foundry和Pivotal集装箱服务（基于Kubernetes）进行了环境化。 https://www.loomsystems.com/blog/everything-you-need-to-know-about-pks-in-3-acts?_lrsc=ae2c4d5a-294e-4484-8ea8-e6beccfc4caa 20: Jenn Strater - 一个Spring REST文档的专家，除了许多其他内容之外，还汇集了一个介绍测试驱动文档的精彩演示文稿（根据Spring REST文档，natch）。 https://speakerdeck.com/jlstrater/test-driven-docs-apiconf-de-2017 21: IBM最近发布了他们的J9 JVM。这篇文章让你对J9这个名字背后的独特历史有一点了解。 https://medium.com/@rservant/how-did-the-j9-in-openj9-get-its-name-95a6416b4cb9?source=userActivityShare-a17df5ec14a4-1505939701 22: 这篇文章关于API文档的十个好主意与Spring并没有任何关系，但它似乎强调了这一点：Spring REST文档是一个好主意（TM）！ https://alistapart.com/article/the-ten-essentials-for-good-api-documentation","tags":[{"name":"翻译","slug":"翻译","permalink":"http://baiwenhui.com/tags/翻译/"},{"name":"Spring周报","slug":"Spring周报","permalink":"http://baiwenhui.com/tags/Spring周报/"}]},{"title":"算法中的反转","date":"2017-09-17T05:27:55.000Z","path":"2017/09/17/算法中的反转/","text":"前言一般工作中，可能不会自己去实现元素反转的操作。因为目前的高级语言基本已经帮我们实现好了，我们要做的就是使用好相关的函数就可以了。但是对于知识的认知不能只停留在表面，有些时候更需要去寻求底层的实现原理，这样一来，对于我们自身能力的提高有很大帮助! 数组元素的反转有n个元素的数组，我们可以得到该数组的大小。需要做的就是把第一个元素和最后一个元素进行调换位置即可，对于奇数数组和偶数数组处理类似。只不过奇数数组我们不用管中间的那个元素，比如奇数数组处理思路如下： int[] oddArray = new int[]{ 1, 2, 3 }; 反转这个数组的方法只需要进行将索引为0的1和索引为2的3元素进行位置的调换即可完成。 偶数数组处理思路如下： int[] oddArray = new int[]{ 1, 2, 3, 4 }; 同奇数的处理思路一样，将数组索引为0的元素与索引为3的元素换位，将索引为1的元素与索引为2的元素进行换位。 明白了以上的解决思路，写代码就简单了，具体的实现方案如下： 123456789101112class Solution&#123; private static void reverseArray(int[] array) &#123; final int len = array.length - 1; final int mid = array.length &gt;&gt; 1; for (int i = 0; i &lt; mid; i++) &#123; final int temp = array[len - i]; array[len - i] = array[i]; array[i] = temp; &#125; &#125;&#125; 单链表元素的反转1.什么是链表？ 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。——-摘抄自维基百科 2.定义链表数据结构 通过概念我们可以了解到，链表的结构应该包含当前节点的值，和指向下一个节点的指针元素。那么，便可以对其数据结构做如下定义： 123456789101112131415161718class ListNode &#123; int val; ListNode next; ListNode(int val)&#123; this.val = val; &#125; @Override public String toString() &#123; return &quot;ListNode&#123;&quot; + &quot;val=&quot; + val + &quot;, next=&quot; + next + &apos;&#125;&apos;; &#125;&#125; 3.初始化链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LinkedListReverse &#123; public static void main(String[] args) &#123; int count = 9; ListNode t = initListNode(count,count); printLinkedList(t); &#125; private static ListNode initListNode(int len , int count) &#123; ListNode t = new ListNode(1); ListNode x = t; for(int i = 2; i &lt;= len; i++)&#123; // x 用于指向新创建的节点，将新创建的节点指向当前节// 点的下一个引用 x = (x.next = new ListNode(i)); &#125; return t; &#125; private static void printLinkedList(ListNode head) &#123; ListNode node = head; while(node != null)&#123; System.out.println(node.val); node = node.next; &#125; &#125;&#125;class ListNode &#123; int val; ListNode next; ListNode(int val)&#123; this.val = val; &#125; @Override public String toString() &#123; return &quot;ListNode&#123;&quot; + &quot;val=&quot; + val + &quot;, next=&quot; + next + &apos;&#125;&apos;; &#125;&#125; 通过以上的方式我们创建了一个从1到9的单向链表。 4.反转单链表 反转思路：这个实现的思路和数组元素的反转类似，只不过需要做一点稍微的变化，我们知道单链表的最后一个元素指向null,有1-10之间的元素链表,只需要将值为1的节点引用指向null,值为2的节点引用指向1，以此类推，根据以上分析可以得到以下方法，暂且将方法命名为 reverse ，方法实现如下：1234567891011121314public static ListNode reverse(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while (curr != null) &#123; //save next node ListNode nextTemp = curr.next; //change curr.next = prev; //cache prev node prev = curr; curr = nextTemp; &#125; return prev; &#125; 关于反转的详细思路结合reverse方法参考如下分析过程：12345678910111213141516171819202122232425262728293031323334353637383940414243/*单链表反转分析过程：1-&gt;2-&gt;3-&gt;4prev = nullcurr = head(值为1的节点)nextTemp -&gt; next (值为2的节点)curr.next = prev(当curr的值为1时，它的next为null)设置完毕后，将当前节点(值为1的节点)缓存起来，供下一次循环到的节点进行使用prev -&gt; curr最后，将当前节点的引用指向 next (值为2的节点)第一次循环之后，可以得到如下数据：2--&gt;1--&gt;null第二次循环此时，curr是值为2的节点nextTemp -&gt; next (值为3的节点)curr.next = prev(当curr的值为2时，它的next为prev，即：next指向上一次循环时缓存下来的值为1的节点)再讲prev引用指向当前遍历的值为2的节点，供下一次循环使用,即prev = curr (值为2的节点)接着将当前值为2的节点指向值为3的节点第二次循环之后，结果变为：3-&gt;2-&gt;1-&gt;null以此类推，当遍历到节点为4的值时，curr=null，循环结束，具体结果为：4-&gt;3-&gt;2-&gt;1-&gt;null通过以上的分析，可以深刻理解单链表的反转操作套路。*/ Java实现数组元素的反转demo https://gist.github.com/strongant/7e2baab6291a569586bab1b97b0b22c6 Java实现单链表的反转demo https://gist.github.com/strongant/f31727433ce0af4d2f6afb14ff304a19","tags":[{"name":"算法","slug":"算法","permalink":"http://baiwenhui.com/tags/算法/"}]},{"title":"使用Httpie来替代CURL","date":"2017-09-10T13:51:00.000Z","path":"2017/09/10/使用Httpie来替代CURL-1/","text":"当下的一些比较人们的测试接口的客户端工具大概有以下几种： Postman（使用最多，一个基于Chrome的app） CURL（在终端下工作的文件传输工具） Httpie（终端下比较友好、简洁、特性更多，功能更强大） 个人在终端下比较推荐使用Httpie，原因如下： 举个例子，如果我们发起一个请求，获取一个JSON字符串，如果我们使用CURL进行获取的话，需要使用管道命令结合python自带的json.tool这个脚本才能完成，curl https://httpbin.org/get | python -m json.tool 如果我们使用Httpie的话，只需要这样：http https://httpbin.org/get,可以发现它不仅返回了body内容，也同时返回了header信息。当然如果我们只需要看body内容，此时只需要进行筛选即可，使用如下命令请求即可：http https://httpbin.org/get --body,如果只需要header信息，可以这样：http https://httpbin.org/get --header。更多特性，请参考：https://httpie.org/ Httpie默认会将返回的JSON数据进行格式化，不再需要二次转换，并且它会使用颜色将一些不同类型的数据加以区分，这样也方便我们进行查看。 这里介绍下Mac下的安装方式：由于Httpie依赖Python，一般情况下Mac下已经自带了Python环境，只不过版本可能并不是最新的。使用brew安装即可： 1brew install httpie 安装成功后我们进行测试是否可用：1http ifconfig.me/all.json 正常情况下便可以得到带颜色的格式良好的JSON数据。","tags":[{"name":"工具","slug":"工具","permalink":"http://baiwenhui.com/tags/工具/"}]},{"title":"官方Spring周报-20170905","date":"2017-09-07T14:31:00.000Z","path":"2017/09/07/官方Spring周报-20170905/","text":"Spring的粉丝们，欢迎来到本周的另一期官方周报！这个星期我在香港看这个惊人的YOW！然后是新加坡的YOW。这些会议都是来自澳大利亚顶尖的会议，而且会议很新颖。如果你在这两个地方，我希望你会来。 http://www.yowconference.hk/ http://www.yowconference.sg/ 1.介绍下关于Spring Cloud Data Flow最重要的一个方面。 Spring Cloud Data Flow大牛Eric Bottard首先介绍了Spring Cloud Data Flow Shell本身。 https://spring.io/blog/2017/08/29/spring-cloud-data-flow-tips-tricks-interacting-with-the-shell 2.Spring Cloud贡献者Ryan Baxter刚刚宣布了Spring Cloud Edgeware M1 的发布。新版本包括对各种项目的更新以及新的Spring Cloud Gateway项目。此版本基于Spring Boot 1.5.x。 https://spring.io/blog/2017/08/29/spring-cloud-edgware-m1-is-now-available 3.Spring Cloud联合创始人Spencer Gibb刚刚宣布了Spring Cloud Finchely M2的发布。这个新版本基于Spring Boot 2.0.x，所以是基于Java 8。它还支持Spring Cloud Gateway中更多更酷的功能。在Spring Cloud Gateway和其他版本中，一个常见主题是反应性支持。 https://spring.io/blog/2017/08/30/spring-cloud-finchley-m2-is-available 4.Spring Cloud Flow大牛Thomas Risberg在本文中介绍了针对Kubernetes的Spring Cloud Data Flow的Helm安装程序。 Helm是Kubernetes的包管理者。 https://spring.io/blog/2017/08/31/simple-installation-of-data-flow-for-kubernetes-with-helm 5.这个应用现代化的Pivotal和Apigee白皮书是一个很好的阅读题材。 https://content.pivotal.io/apigee/application-modernization?_lrsc=9d76ba9e-eb43-42fb-b85d-9e5b48373ac4 6.Matt McCandless称Spring Boot老而弥新，这是个很好的起步。 https://dzone.com/articles/spring-boot-the-right-boot-for-you-1 7.这篇关于使用Spring Boot的Quartz Scheduler的文章是曾经看过的一篇文章。我喜欢。 http://www.opencodez.com/java/quartz-scheduler-with-spring-boot.htm 8.看起来要想Java 9发布，这个新的Java版本将会有6个月的时间。我个人欢迎新版本。 https://jcp.org/aboutJava/communityprocess/ec-public/materials/2017-08-15/JCP-EC-Minutes-August-2017.html 9.我真的很喜欢这个俄语的帖子，介绍Spring Boot的应用程序开发。 https://alexkosarev.name/2017/08/08/application-development-with-spring-part-1/ 10.上周Pivotal与Google和VMWare合作，宣布了Pivotal Cloud Foundry生态系统 - Pivotal Container Service - 由BOSH管理的Kubernetes服务的下一步工作。我们从TechCrunch片中得到一些细节。 https://www.blog.google/topics/google-cloud/vmware-and-pivotal-launch-new-hybrid-kubernetes-solution-optimized-gcp/ https://techcrunch.com/2017/08/29/seven-moves-that-led-to-the-vmware-pivotal-google-partnership/amp/ 11.我喜欢这个Auth0在集成Spring Boot与SQL数据库（PostgreSQL），JPA和Liquibase。 https://auth0.com/blog/integrating-spring-data-jpa-postgresql-liquibase/ 12.来自JHipster的这篇关于“API优先开发”的文章很有趣。 http://www.jhipster.tech/doing-api-first-development/ 13.Spring Boot 2.0具有反应弹性框架5和Java 8基准线，肯定会令人印象深刻。新版本中我最喜欢的功能之一就是支持Spring Boot Actuator端点的REST-stack（响应式Spring WebFlux，Spring MVC或JAX-RS）。 https://www.infoq.com/news/2017/08/spring-boot-2-actuator-endpoints 14.看看这个优秀的网络研讨会，了解为什么IntelliJ IDEA是Grails应用程序的首选。我喜欢这个，因为Grails 3是基于Spring Boot的，因为Jeff Scott Brown是一个伟大的演讲者，因为IntelliJ做了一个漂亮的好IDE。 https://blog.jetbrains.com/idea/2017/07/webinar-recording-why-intellij-idea-is-the-premier-ide-for-grails-3/ 15.严格来说，这与Spring不是很相关，但它是值得一读的。丹尼尔·布莱恩特（Daniel Bryant）在这篇文章中描述了测试微服务（以及您可能使用的所有组件）的全方位方法。 https://specto.io/blog/2016/8/16/recipe-for-designing-building-testing-microservices/ 16.我喜欢这个来自Spring Data的StackOverflow响应Oliver Gierke：如何在Spring Boot中选择性升级依赖项？ https://stackoverflow.com/questions/45967464/how-to-selectively-upgrade-a-dependency-in-spring-boot-sample-case-spring-dat 17.如果您想快速了解一下Cloud Foundry服务代理商，请阅读本文。 http://www.automate-it.today/about-cloud-foundry-service-brokers/ 18.这篇也不是严格来说与Spring有关，但对于构建云原生应用程序的一些Spring用户来说，这对于Java云主机服务的成本降低策略来说非常有用。 https://www.infoq.com/articles/java-cloud-cost-reduction","tags":[{"name":"Spring官方周报","slug":"Spring官方周报","permalink":"http://baiwenhui.com/tags/Spring官方周报/"}]},{"title":"Java 微服务实践- Spring Boot 系列（十四）WebService-学习笔记","date":"2017-08-21T14:46:00.000Z","path":"2017/08/21/Java-微服务实践-Spring-Boot-系列（十四）WebService-学习笔记/","text":"写在前面的话，之前曾在项目中使用过Webservices，记得当时使用过Apache的CXF，Apache CXF = Celtix + XFire。 随着RESTful服务的越来越流行，渐渐地WebService技术已经渐渐被人们所淘汰。下面主要为了技术的温习，跟上小马哥一起再次复习下那些年我们使用过的WebService。 Web Services 定义：又称之为 Web Service，是一种设计通过网络来支持相互协作的机器间交互的软件系统。它拥有被机器可处理的格式所描述的接口（如：WSDL），规定使用 SOAP消息的方式与其他系统交互，典型地以HTTP传输、XML序列化以及联合其他Web 相关标准。— W3C, Web Services Glossary 标准整合方式&emsp;XML（可扩展标记语言）&emsp;SOAP（对象访问）&emsp;WSDL（网络服务描述语言）&emsp;UDDI（通用描述、发现与集成服务） 什么是 SOAP？ SOAP 指简易对象访问协议SOAP 是一种通信协议SOAP 用于应用程序之间的通信SOAP 是一种用于发送消息的格式SOAP 被设计用来通过因特网进行通信SOAP 独立于平台SOAP 独立于语言SOAP 基于 XMLSOAP 很简单并可扩展SOAP 允许您绕过防火墙SOAP 将被作为 W3C 标准来发展 SOAP 数据封装 SOAP 消息：在SOAP节点之间表达交换的信息SOAP 信封：鉴定SOAP 消息的XML封装元素SOAP 头块：SOAP 头的基本单元SOAP 头：一个或多个SOAP 头块集合SOAP 主体：交给接收端包含消息的主体SOAP 故障：SOAP 节点故障时处理消息 什么是WSDL? WSDL 指网络服务描述语言WSDL 使用 XML 编写WSDL 是一种 XML 文档WSDL 用于描述网络服务WSDL 也可用于定位网络服务WSDL 还不是 W3C 标准 什么是 UDDI？ UDDI 是一个独立于平台的框架，用于通过使用 Internet 来描述服务，发现企业，并对企业服务进行集成。UDDI 指的是通用描述、发现与集成服务UDDI 是一种用于存储有关 web services 的信息的目录。UDDI 是一种由 WSDL 描述的 web services 界面的目录。UDDI 经由 SOAP 进行通信UDDI 被构建入了微软的 .NET 平台 以上概念定义解释来自w3cschool 其中需要注意的有使用Java6以后自带的xjc工具根据xsd生成webservices相关实体代码命令：1xjc -d src/main/java -p com.example.springbootwebservices.domain src/main/resources/META-INF/schemas/user.xsd -d表示指定java包路径的相对目录 具体SpringBoot中使用webservices案例请参考：https://github.com/mercyblitz/segmentfault-lessons/tree/master/spring-boot/lesson-14/spring-boot-lesson-14","tags":[{"name":"springboot","slug":"springboot","permalink":"http://baiwenhui.com/tags/springboot/"},{"name":"webservices","slug":"webservices","permalink":"http://baiwenhui.com/tags/webservices/"}]},{"title":"HTTP状态码图示","date":"2017-08-13T08:00:00.000Z","path":"2017/08/13/HTTP状态码图示/","text":"这里总结下我们日常开发中常用的HTTP状态码，分享一个老外对HTTP状态码形象化用图片表示的网站：https://http.cat/ 总结如下： 表示服务器已经接收到了请求头，并且客户端应该继续发送请求体。表示请求方已经要求服务器切换协议，并且服务器已经接受并会进行处理。HTTP 请求成功的标准应答。实际的应答内容由请求使用的方法来决定。请求已经被接受，并且请求所对应的资源已经被创建。请求已被接受，尚未完成处理，也有可能会被拒绝。在成功处理请求后服务器并没有返回任何实体内容。依照子请求的数量的不同，消息体包含不同的响应代码。表示被请求的资源可以提供多种选项让客户端进行选择该请求应当被定向到给定的URI（统一资源定位符）这是一个工业实践和标准相互矛盾的例子。一些Web应用和框架会使用302状态码对应当前请求的响应可以使用GET方法从另一个URI获取表示资源自上次请求以来没有被改变。（译注：被请求的资源必须通过指定的代理才能被访问） 大多数HTTP客户端不会正确响应这个状态码，主要是出于安全性的原因在这种情况下，请求会从另外的URI响应但是未来的请求仍会使用原始的URI因为错误的语法，请求不能完成当需要授权，但授权失败或还没有授权时返回的状态码该状态码是为了将来可能的需求而预留的。这个代码通常不使用，但是其最初的意图是可以被某种电子货币所使用。请求有效，但是服务器拒绝响应它。请求的资源不能找到，但是将来也许可用。请求某资源时使用的请求方法不能被该资源所支持。被请求资源能够产生的内容不满足请求头中指定的类型。服务器等待请求超时因为请求中存在冲突导致请求无法被处理被请求的资源已不可用，同时后续也不再可用。请求所对应的资源需要指明长度，但请求中并没有包含长度。其请求数据实体过大，超过服务器处理能力。URI过长，服务器不能处理客户端请求部分文件，但是服务器并不能提供这个范围值。服务器不能满足请求头重指定的要求。在实际HTTP服务器中不会实现该状态码请求格式正确但是因为存在语意错误无法响应。当前资源被上锁因为之前的请求失败而导致了本次请求失败在WebDav Advanced Collections 草案中定义客户端应该切换到不同的协议用户在指定时间内发送的请求过多。因为请求中的单个域过大、或者全部域全加起来过大。在Nginx记录中使用，表示服务器没有向客户端返回信息并且已经关闭了连接微软所扩展的一个状态码当没有其他更加确切的信息可以给出时，给出的一个一般性错误信息。作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应服务器当前不可用。请求的透明内容协商导致循环引用服务器无法存储完成请求所必须的内容。服务器在处理请求时发现一个无限循环尽管很多服务器使用该协议，但其并没有在任何RFC中说明这个状态码没有在任何RFC中说明，但微软公司在用。","tags":[{"name":"http","slug":"http","permalink":"http://baiwenhui.com/tags/http/"}]},{"title":"Groovy入门-变量与变量类型","date":"2017-08-13T06:34:00.000Z","path":"2017/08/13/Groovy入门-变量与变量类型/","text":"Groovy的变量与变量类型变量与常量的定义，维基百科对其定义如下变量：变量通常是可被修改的，即可以用来表示可变的状态。常量：指一个数值固定不变的常量，例如圆周率、自然对数的底。与之相反的是变量。 动态变量与静态变量动态变量：动态变量在程序执行过程中建立，随函数的调用需要动态的分配存储空间，调用结束释放所占用存储空间。静态变量：静态变量（Static Variable）在计算机编程领域指在程序执行前系统就为之静态分配（也即在运行时中不再改变分配情况）存储空间的一类变量。 Groovy中的变量类型Groovy中可以使用的变量类型有数字（Number）类型、字符串（String）类型、布尔（Boolean）类型以及引用（Reference）类型。 1.数字（Number）类型：包括整数类型和浮点数类型。 其中，整数包含正数、负数和零，都是Integer类的实例，比如1、-1和0都属于整数类型。 浮点数包含小数部分，都是BigDecimal类的实例，比如1.11、-3.11都属于常见的浮点数类型。在数字字面值加上可显示指定变量的类型，整数Long型（Long）、整数BigInteger型（BigInteger）、浮点型Float（Float）、浮点数Double（Double）。 2.字符串（String）类型：通过使用引号将文本值组织起来，如’Hello’、”Hello”、”””Hello”””，其中使用单引号（‘）、双引号(“”)、三双引号（”””）都是允许的。 3.布尔（Boolean）类型： 包含true和false。如def judge = true,def 在groovy中表示任意类型，在程序运行期动态推到其最终类型。 4.引用（Reference）类型：用于表示指向一个对象。比如：def user = new User(name:”张三”)。其中user表示的就是User对象的实例。 Groovy中变量的声明和使用 声明的变量名称通常被称为标识符。在Groovy中，标识符的命名规则如下： 标识符必须由字母和数字组成，大小写敏感，标识符的首字符必须是字母。下划线(_)允许出现在标识符中，以字母看待。标识符绝对不允许是 Groovy关键词。声明变量时需要引入变量名称，可以为变量指定初始值，也可以确定变量能被引用的作用域或者作用范围。当在程序中首次使用某个变量时，需要使用Groovy关键def关键字声明，不能在同一个作用域内声明两次相同的变量名。 示例：1234567891011121314151617181920212223242526272829303132333435363738394041/** * Groovy中对不同类型变量的定义和使用 * @author strongant * Contact me at &lt;a href=&quot;mailto:strongant1994@gmail.com&quot;&gt;strongant1994@gmail.com&lt;/a&gt; * @see * @since 2017/8/13 */class DefineUseVariable &#123; public static void main(String[] args) &#123; // 声明一个值为admin，类型为String的变量 def name = &apos;admin&apos; // 声明一个值为10的数字，类型为Integer def age = 10 // 声明一个值为20.0的数字，类型为BigDecimal def money = 20.0 // 声明一个值为true的布尔变量，类型为Boolean def isMale = true // 再次声明一个值为admin，类型为String的变量，下面代码将运行错误。 //def name = &quot;Bob&quot; // 输出变量的值和类型。 //注意，在输出的时候，如果要使用&apos;$&apos;符号进行输出变量，则字符串必须使用双引号的三双引号的情况下，才可以正常输出变量值。 // 如果是单引号，则不会输出变量值，原样输出 println &quot;name is $&#123;name&#125;. I&apos;m $&#123;age&#125; years old. I hava $&#123;money&#125; dollars.&quot; println &quot;name type: $&#123;name.class&#125;&quot; println &quot;age type: $&#123;age.class&#125;&quot; println &quot;money type: $&#123;money.class&#125;&quot; println &quot;isMale type: $&#123;isMale.class&#125;&quot; // 声明一个值为10.0的浮点型的变量，类型为Float def floatTypeVariable = 10.0F println &quot;floatTypeVariable type: $&#123;floatTypeVariable.class&#125;&quot; // 声明一个值为10.0的浮点型的变量，类型为Double def doubleTypeVariable = 10.0D println &quot;doubleTypeVariable type: $&#123;doubleTypeVariable.class&#125;&quot; // 声明一个值为10000的长整型的变量，类型为Long def longTypeVariable = 10000L println &quot;longTypeVariable type: $&#123;longTypeVariable.class&#125;&quot; // 声明一个值为10000的长整型的变量，类型为大长整型BigInteger def bigIntegerTypeVariable = 10000G println &quot;bigIntegerTypeVariable type: $&#123;bigIntegerTypeVariable.class&#125;&quot; &#125;&#125; 示例的代码也可以在此地址找到：https://gist.github.com/strongant/22c489f5a51f416d1bf3e97d86f031dd Groovy变量自动转换和强制转换示意图 Groovy中关键字abstract case do finally instanceof package strictfp throws with any catch double float int private super transient as assert char class else enum for if interface long protected public switch synchronized true try boolean continue extends implements native return this void break def false import new short threadsafe volatile byte default final in null static throw while","tags":[{"name":"groovy","slug":"groovy","permalink":"http://baiwenhui.com/tags/groovy/"}]},{"title":"Groovy入门-安装","date":"2017-08-13T03:03:00.000Z","path":"2017/08/13/Groovy入门/","text":"使用groovy开发差不多已经四个多月了，这里分享一些自己在groovy方面的一些总结。 介绍 Groovy 是一种新兴的运行于 Java™ 平台之上的编程语言 它提供与已有 Java 代码的无缝集成，并引入了一些强大的新特性，比如闭包和元编程 简单来讲，Groovy 就是在 21 世纪 Java 语言的的效果 Groovy是Java平台上脚本语言，抽象程度更高，可以更简单快速的开发，可以编写更少的代码 与Java语言无缝集成，可以称为“超级Java” 使用“类JAVA语法”，Java程序员可以快速过度 Groovy与Java二进制兼容，都生成字节码，所以可以与使用Java语言所编写的框架和组件完美集成，并且效率安全方面比其他脚本语言要高 Groovy对象就是Java对象，使用JDK相同的API 可以保护整个Java产业在Java上巨大的投资 在中小型项目中可以替代Java，在大型Java项目中可以嵌入Groovy应用 安装，使用官网推荐的安装方法首先安装SDKMAN! (一个软件开发工具包管理工具)1$ curl -s get.sdkman.io | bash 使其SDKMAN工具生效1$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot; 安装最新版本的Groovy: 1$ sdk install groovy 等待一会儿之后，显示安装完毕，此时我们可以使用此命令验证groovy是否安装成功 1$ groovy -version 安装2 在官网下载groovy sdk下载地址:https://akamai.bintray.com/9a/9a20d8868edbbc82a8edd03b6ae6f7dfbe406e42a468f2c44d5285493f679676?__gda__=exp=1466580235~hmac=4c1a4086a45aca9a522aac513d022d04f90eec437163110a69a441bf823143a2&amp;response-content-disposition=attachment%3Bfilename%3D%22apache-groovy-sdk-2.4.7.zip%22&amp;response-content-type=application%2Fx-www-form-urlencoded 进行解压： 1$ unzip apache-groovy-sdk-2.4.7.zip 配置到全局变量或者用户所在的变量环境 12345sudo vi /etc/profile//添加groovy解压目录所在的位置//我当前安装目录为：/home/devbwh/groovy-2.4.7，在/etc/profile文件末尾添加一下配置：export GROOVY_HOME=/home/devbwh/groovy-2.4.7export PATH=GROOVY_HOME/bin:$PATH 使其生效 1source /etc/profile 安装3(Mac安装)1brew install groovy","tags":[{"name":"groovy","slug":"groovy","permalink":"http://baiwenhui.com/tags/groovy/"}]},{"title":"跟小马哥学习SpringBoot","date":"2017-08-12T06:36:23.000Z","path":"2017/08/12/跟小马哥学习SpringBoot/","text":"这里推荐一个不错的Spring Boot系列讲座，讲师简介如下： 小马哥，阿里巴巴技术专家，从事十余年Java EE 开发，国内微服务技术讲师。目前主要负责微服务技术推广、架构设计、基础设施、迁移等。重点关注云计算、微服务以及软件架构等领域。获得过 SUN Java（SCJP、SCWCD、SCBCD）以及 Oracle OCA 等的认证。 讲座大纲 Java 微服务实践 - Spring Boot 系列（一）初体验 Java 微服务实践 - Spring Boot 系列（二） Web篇（上） Java 微服务实践 - Spring Boot 系列（三）Web篇（中） Java 微服务实践 - Spring Boot 系列（四）Web篇（下） Java 微服务实践 - Spring Boot 系列（五）嵌入式Web容器 Java 微服务实践 - Spring Boot 系列（六）数据库 JDBC Java 微服务实践 - Spring Boot 系列（七）MyBatis Java 微服务实践 - Spring Boot 系列（八）JPA Java 微服务实践 - Spring Boot 系列（九）NoSQL Java 微服务实践 - Spring Boot 系列（十）缓存 Java 微服务实践 - Spring Boot 系列（十一）消息 Java 微服务实践 - Spring Boot 系列（十二）验证 Java 微服务实践 - Spring Boot 系列（十三）WebSocket Java 微服务实践- Spring Boot 系列（十四）WebService Java 微服务实践 - Spring Boot 系列（十五）安全 Java 微服务实践 - Spring Boot 系列（十六）日志 Java 微服务实践 - Spring Boot 系列（十七）监管 Java 微服务实践 - Spring Boot 系列（十八）配置 Java 微服务实践 - Spring Boot 系列（十九）测试 Java 微服务实践 - Spring Boot 系列（二十）自定义启动器 原文链接：https://segmentfault.com/u/mercyblitz/lives?type=started本文作者：小马哥","tags":[]},{"title":"Mac上传图片至图床神器","date":"2017-08-12T03:47:00.000Z","path":"2017/08/12/Mac上传图片至图床神器/","text":"推荐一款Mac上上传图片到图床的神器：IPic具体的下载和使用方法可以戳这儿https://toolinbox.net/iPic/","tags":[{"name":"工具","slug":"工具","permalink":"http://baiwenhui.com/tags/工具/"},{"name":"图床","slug":"图床","permalink":"http://baiwenhui.com/tags/图床/"},{"name":"图片","slug":"图片","permalink":"http://baiwenhui.com/tags/图片/"}]},{"title":"Git常用命令记录","date":"2017-08-11T15:13:00.000Z","path":"2017/08/11/Git常用命令记录/","text":"Git常用命令记录","tags":[{"name":"git","slug":"git","permalink":"http://baiwenhui.com/tags/git/"}]},{"title":"使用angular中的service和filter编写组件树","date":"2017-08-05T08:49:00.000Z","path":"2017/08/05/使用angular中的service和filter编写组件树/","text":"学习《AngularJS深度剖析与实践》总结 在我们平时的开发中，需要对某些数据进行以树的形式进行展现，比如：权限角色、菜单、嵌套评论等。这个时候我们需要使用angular进行对数据抽象，构造我们自己的组件树： 例子：我们就拿主题树作为一个例子，然后一步一步去优雅的实现它: 首先我们准备好angular的库文件，建立好相应的目录及文件，按照angular遵循的风格：约定优于配置。首先我们创建一个用于展示的目录，theme-tree1mkdir theme-tree &amp;&amp; cd $_ 2.创建需要展示的html页面文件:1touch index.html 3.创建存放项目js文件的目录:1mkdir js 4.创建存放angular项目的controller目录、service目录和filter目录:1mkdir controller &amp;&amp; mkdir service &amp;&amp; mkdir filter 5.创建angular项目的入口文件，app.js1cd js &amp;&amp; touch app.js 6.目前先不考虑UI效果部分，主要以实现功能为主，我们使用bower来安装和管理相应的js第三方库文件，如果没有安装bower工具，可以借助npm进行安装-npm install -g bower ,在我们创建的theme-tree目录下，键入如下命令安装angular库的依赖：1bower install angular --save 以上命令实行完毕后我们的目录结构如下： 7.接下来我们开始编辑js/app.js入口文件：1angular.module(&apos;myApp&apos;, []); 8.接下来我们开始编写控制器文件js/controller/index.client.controller.js:1234567891011121314151617181920212223242526272829303132333435363738394041angular.module(&apos;myApp&apos;).controller(&quot;ThreedTreeCtrl&quot;,function ThreedTreeCtrl(tree) &#123; var vm = this; vm.items = [&#123; id: 1, title: &quot;Java&quot;, poster: &quot;Messi&quot;, dateCreated: &quot;2012-02-19T00:00:00&quot;, items: [&#123; id: 11, title: &apos;Spring&apos;, poster: &apos;John&apos;, dateCreated: &quot;2012-02-19T00:00:00&quot;, items: [ &#123; id: 111, title: &apos;AOP&apos;, poster: &apos;Mike&apos;, dateCreated: &quot;2016-02-19T00:00:00&quot;, items: [ &#123; id: 1111, title: &apos;IOC&apos;, poster: &apos;Jack&apos;] &#125; ] &#125;, &#123; id: 2, title: &quot;SpringBoot&quot;, poster: &quot;Lucy&quot;, dateCreated: &quot;2011-02-19T00:00:00&quot; &#125; ] &#125;, &#123; id: 2, title: &quot;JavaScript&quot;, poster: &quot;Jack&quot;, dateCreated: &quot;2012-02-19T00:00:00&quot;, &#125; ];&#125;); 以上内容很简单，构建了一个ThreedTreeCtrl控制器，里面嵌套了一些随意的数据，主要是为了模拟父子关系； 9.接下来我们编辑js/service/index.client.service.js文件，用于对数据进行附加相应的行为。思考一下，当我们有了这样一组数据后，我们要为它添加什么方法和属性，首先应该添加父节点是否折叠，此属性主要是为了在界面显示的时候展开或折叠子节点数据。当展开的时候我们使用“-”表示，折叠的时候我们使用”+”表示，当折叠时单击节点应该展开子节点，当展开的时候，单击子节点应该折叠父节点；将新增的属性和方法为了减小和原始数据冲突，并且这些数据通过$http或者$resource提交给服务器，它们所调用的angular.toJso()函数会忽略所有以$开头的属性，这样我们扩展的属性就不会被提交到服务端了。还有一个方便的是，当我们看到数据上有”$”开头的属性就是扩展的属性。接下来我们实现它：123456789101112131415161718192021222324252627282930angular.module(&apos;myApp&apos;).service(&apos;tree&apos;,function Tree()&#123; var self = this; //为每一项节点添加属性和方法 var enhanceItem = function(item,childrenName)&#123; item.$hasChildren = function()&#123; var subItems = this[childrenName]; return angular.isArray(subItems) &amp;&amp; subItems.length; &#125;; item.$foldToggle = function()&#123; this.$folded = !this.$folded; &#125;; item.$isFolded = function()&#123; return this.$folded; &#125;; &#125;; //对传进来的数据进行强化 this.enhance = function(items,childrenName)&#123; if(angular.isUndefined(childrenName))&#123; childrenName = &quot;items&quot;; &#125; angular.forEach(items,function(item)&#123; enhanceItem(item,childrenName); //如果有子节点则递归处理 self.enhance(item[childrenName],childrenName); &#125;); console.log(items); return items; &#125;;&#125;); 10.这样我们完成了对数据进行强化，此时我们如果直接在controller调用service的enhance 方法，将服务端返回的json数据进行加强，为他们添加的相应的属性和方法，然后在页面进行展示调用就可以了，但是这样感觉比较脏，不干净，我们不在contrller直接调用service里面的enhance 方法，我们可以创建一个过滤器来对数据进行添加过滤的功能，接下来我们开始编辑filter/index.client.filter.js: 123456angular.module(&apos;myApp&apos;).filter(&apos;tree&apos;,function(tree)&#123; return function(items,childrenName)&#123; tree.enhance(items,childrenName); return items; &#125;;&#125;); 11.接下来编写html文件，开始对主题树进行展现并且引入相关文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;ThreedTreeCtrl as vm&quot;&gt; &lt;ul ng-if=&quot;vm.items&quot;&gt; &lt;li ng-repeat=&quot;item1 in vm.items | tree&quot;&gt; &lt;div ng-click=&quot;item1.$foldToggle()&quot;&gt; &lt;span ng-if=&quot;item1.$hasChildren()&quot;&gt; &lt;span ng-if=&quot;!item1.$isFolded()&quot;&gt;-&lt;/span&gt; &lt;span ng-if=&quot;item1.$isFolded()&quot;&gt;+&lt;/span&gt; &lt;/span&gt; &#123;&#123; item1.title &#125;&#125; &lt;/div&gt; &lt;ul ng-if=&quot;item1.$hasChildren() &amp;&amp; !item1.$isFolded()&quot;&gt; &lt;li ng-repeat=&quot;item2 in item1.items&quot;&gt; &lt;div ng-click=&quot;item2.$foldToggle()&quot;&gt; &lt;span ng-if=&quot;item2.$hasChildren()&quot;&gt; &lt;span ng-if=&quot;!item2.$isFolded()&quot;&gt;-&lt;/span&gt; &lt;span ng-if=&quot;item2.$isFolded()&quot;&gt;+&lt;/span&gt; &lt;/span&gt; &#123;&#123; item2.title &#125;&#125; &lt;/div&gt; &lt;ul ng-if=&quot;item2.$hasChildren() &amp;&amp; !item2.$isFolded()&quot;&gt; &lt;li ng-repeat=&quot;item3 in item2.items&quot;&gt; &#123;&#123; item3.title &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;bower_components/angular/angular.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/controller/index.client.controller.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/service/index.client.service.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/filters/index.client.filter.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 此时我们便完成了对主题树功能的实现，在index.html文件中，我们只展示了两层嵌套关系以作为示例，根据自己的业务场景进行扩展。以上实现还不够优雅，等待以后需要将主题递归树封装为指令，最后附上github地址:https://github.com/strongant/angularjs源码位于此仓库下的angular-tree目录，欢迎提出issue。","tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://baiwenhui.com/tags/angularjs/"}]},{"title":"监听chrome extension popup页面消失","date":"2017-08-05T08:46:00.000Z","path":"2017/08/05/监听chrome-extension-popup页面消失/","text":"需求 当用户不小心点击了鼠标或者离开了扩展的popup页面，此时需要对一些数据进行清空或者删除一些不必要的数据. 遇到的问题 然而chrome 扩展官方并没有对popup或者browserAction提供相关页面消失时的监听事件 解决办法 通过不断的查找资料和查阅chrome扩展开发文档，我们可以使用消息通信连接的方式解决了这个问题具体步骤: 首先在你需要监听页面消失事件的js文件中与background建立连接，相关代码: 12//这里主要是为了与background建立连接，当页面关闭的时候连接就会断开，此时background中你注册的连接关闭函数此时会执行，因为background环境一直存在，除非你关闭了电脑 var port = chrome.runtime.connect(); 在background环境注册断开连接时需要处理的方法，相关代码: 123456 chrome.runtime.onConnect.addListener(function (externalPort) &#123; externalPort.onDisconnect.addListener(function() &#123; var ignoreError = chrome.runtime.lastError; console.log(&quot;onDisconnect&quot;); &#125;); &#125;); 总结 通过以上的方式便实现了类似对popup页面消失时做一些事情的需求。感谢StackOverFlow，神一样的解决问题社区，致敬！","tags":[{"name":"chrome扩展","slug":"chrome扩展","permalink":"http://baiwenhui.com/tags/chrome扩展/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://baiwenhui.com/tags/JavaScript/"}]},{"title":"上班路上的琐事","date":"2017-08-05T06:59:00.000Z","path":"2017/08/05/生活感慨/","text":"事件起因 骑着电动车上班也有4个月了，总体感觉还是很不错的！由之前坐地铁上班花费1个半小时减少到现在的半个小时，还是很不错的一笔投资！其实后悔电瓶车买的有点迟了，如果早点买的话起码可以在出行方面带来很多方便，虽然现在有很多的共享单车可以骑，但是对于上海这么大的地方和上班距离遥远的情况，对于骑自行车来上班肯定是来不及的，速度也跟不上，根本无法满足自己的需求！可就在昨天下午2017年8月5号18点20分左右，当我插上电动车钥匙，死活就是启动不了电瓶车，而且电瓶车很明显没有一丁点儿电了，大灯不亮，喇叭不响，心里一下难过了，到底什么鬼导致这个问题的发生呢？然后想了想，我靠，中午的时候貌似下很大的雨，不会是雨漏到电瓶或者控制器里面，导致短路了吧？这个只是当时的猜测，后面接着开始用百度进行搜索一下，看网上有没有类似的网友遇到此问题，网上扫了一圈，基本上都说是可能是电瓶进水了，把电瓶晾干就可以骑了，其实当时想给卖车的师傅打电话的，又相信了网上的答案，于是便将车放到车棚里面坐地铁回家了，晚上可是要看《战狼2》的，不然时间来不及了，于是便放下电动车，匆忙往电影院赶！ 事件经过 晚上看完电影，天气湿热湿热，难受至极，晚上浑浑噩噩的睡了一晚上。大清早9点多就起来了，起来便开始准备去公司看看电瓶车是不是像网上说的那样，等到电瓶晾干了，就可以骑了！于是乎开始骑单车、等公交、坐公交、等地铁、坐地铁，从出发到到达公司，大概花费了我2个小时，在这里我不得不吐槽交通问题，其实住的地方离公司只有20公里，有一次我起迟了害怕迟到，就打了个车到公司，花了40块钱。但是花费时间让我很惊讶，只用了10分钟，我就纳闷了，为什么这么快呢？原来是因为坐地铁比较绕，而且也没有直达的公交，如果坐公交的话也是特别绕，所以就浪费了不应该浪费的2个小时时间。这一点可能是因为个人住的地方偏远原因吧，不过我想很多人应该也有类似的愤怒，明明不是很远，却要绕很多路花很多时间才能到目的地。抱怨没用，只能自己想办法解决！到了公司之后去找到电瓶车，幸亏公司的安保措施做得不错，车子没有被偷，谢天谢地！当我插上钥匙，和昨天下午一个样，还是没有电，顿时想：糟糕，肯定是电瓶进水太严重，导致车子彻底没电了，这时候我想打电话找个修车师傅帮我看看，可卖车的地方离公司太远了，就想着要不要找个距离我比较近的修车师傅过来看看，又顾虑这是新车，如果让别人拆开修，人家不给我保修了怎么办，买下车骑了也没有多长时间，不划算！还是打电话问一下原卖车的师傅，我把情况给人家说了一下：昨天中午下了会大雨，车子没有用雨衣盖住，昨天下班后钥匙插上之后，启动不了，纯粹没电！然后又经验的师傅说了下：你检查一下座子下面那个开关是不是把电瓶的电源关闭了。于是我便按照他说的，打开后座，把开关切换了一些，然后用钥匙插上，发现奇迹产生了，电动车一切正常，心里窃喜，不用修了，感谢有经验的老司机！ 又出波折 由于又可以正常骑行了，不用挤地铁，一切恢复正常，心里比较窃喜，骑行的过程中一不小心就撞到了马路边的一个栏杆桩上面，这一撞直接把电瓶车的单撑撞断了，于是骑到卖车的地方花了40块钱焊接了一下，唉，这半天的时间又浪费过去了！无奈！ 事件总结 在平时用车的时候，应该特别小心，注意安全！最后分享一个CCTV7的对电动车电池修复技术的介绍视频，本人觉得讲解的很好，很细致！http://tv.cntv.cn/video/C10391/258219f0a78b491c452527b41bb3088c","tags":[{"name":"随笔","slug":"随笔","permalink":"http://baiwenhui.com/tags/随笔/"}]},{"title":"Grails中一个日期差引起的思考","date":"2017-08-02T14:02:00.000Z","path":"2017/08/02/Grails中一个日期差引起的思考/","text":"需求如下 对某表中的数据进行查询限制，当根据某个条件进行查询表记录时，如果该记录的查询时间与当前服务器时间相差大于一周，则允许查询操作，否则不允许重复查询操作。 编码根据当前需求进行编码，代码如下：1234567891011121314151617181920class ExampleController &#123; def test() &#123; ... def obj = XXX.findByName(&apos;xxx&apos;) def limitDays = 7 if(obj &amp;&amp; daysBetween(obj.queryTime,new Date())&lt;=7)&#123; render([code: 10101, msg: &quot;查询失败，7天内不允许重复查询&quot;, data: []] as grails.converters.JSON) return &#125; ... &#125; //TODO: 将此处判断移动至service或者util类 static def daysBetween(def startDate, def endDate) &#123; use(groovy.time.TimeCategory) &#123; def duration = endDate - startDate return duration.days &#125; &#125;&#125; 出现bug:本地测试程序可以正常执行，但是发现在生产环境下并没有正常执行 错误解决：以为是groovy.time.TimeCategory原生类有bug，将比较日期间隔天数的方法修改为如下: 1234//TODO: 将此处判断移动至service或者util类static boolean keep7Days(endDate)&#123; return (System.currentTimeMillis()-endDate.getTime())&lt;3600*1000*24*7&#125; 修改结果：问题依然存在。 进行分析： 当我们从某张表中根据某个条件查询一条记录，如果该条件对一个多条重复记录，那数据库将按照表中的记录插入顺序返回最初插入的一条记录。因此，当根据某条件进行匹配查询时，应该按照id降序排列后取得第一条即可。 解决办法：123...def obj = XXX.find(&quot;from XXX as b where b.xxx=:xxx order by b.id desc&quot;,[xxx:xxx])... 通过以上方式，我们便可以得到最后插入的记录，此时再使用时间差进行判断就不会出现匹配不正确问题。 总结当项目中遇到bug时应该找到问题的根源再进行解决。在测试的过程中数据应该保持和生产环境数据一致！ 彩蛋推荐两个不错的播客平台： 内核恐慌 比特新声","tags":[{"name":"groovy","slug":"groovy","permalink":"http://baiwenhui.com/tags/groovy/"},{"name":"grails","slug":"grails","permalink":"http://baiwenhui.com/tags/grails/"},{"name":"gorm","slug":"gorm","permalink":"http://baiwenhui.com/tags/gorm/"}]},{"title":"Mac通过brew安装redis","date":"2017-07-26T13:41:00.000Z","path":"2017/07/26/Mac通过brew安装redis/","text":"MacOS下通过brew安装redis安装redis:1brew install redis 安装后的地址为:/usr/local/Cellar/redis/3.2.9 链接redis的launch开机启动配置文件1ln -sfv /usr/local/opt/redis/*.plist ~/Library/LaunchAgents 使用launchctl启动redis，每次开机启动1launchctl load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 通过redis的配置文件进行启动1redis-server /usr/local/etc/redis.conf 停止开机启动redis1launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 安装后的redis默认配置文件地址：1/usr/local/etc/redis.conf 卸载redis12brew uninstall redisrm ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 获取redis的安装信息1brew info redis 测试redis是否启动1redis-cli ping 如果redis返回“PONG”，那么说明连接成功","tags":[{"name":"mac","slug":"mac","permalink":"http://baiwenhui.com/tags/mac/"},{"name":"redis","slug":"redis","permalink":"http://baiwenhui.com/tags/redis/"},{"name":"brew","slug":"brew","permalink":"http://baiwenhui.com/tags/brew/"}]},{"title":"Ubuntu安装Java8环境","date":"2017-07-26T13:32:00.000Z","path":"2017/07/26/Ubuntu安装Java8环境/","text":"Ubuntu 系统安装Java8 JDK1.添加ppa1sudo add-apt-repository ppa:webupd8team/java 2.更新系统1sudo apt-get update 3.开始安装1sudo apt-get install oracle-java8-installer -y 4.验证是否安装成功1java -version 5.安装脚本gist地址(执行脚本时记得回车继续，其中弹出确认安装提示选择是即可，脚本执行完毕后就已经成功安装Java8了，安装大约得等待一段时间，请耐心等待！):https://gist.github.com/strongant/740f58dd6f116a4ff4d156805340bb95","tags":[{"name":"jdk","slug":"jdk","permalink":"http://baiwenhui.com/tags/jdk/"},{"name":"java8","slug":"java8","permalink":"http://baiwenhui.com/tags/java8/"},{"name":"sh","slug":"sh","permalink":"http://baiwenhui.com/tags/sh/"}]},{"title":"终端录制神器-showterm","date":"2017-07-26T12:21:00.000Z","path":"2017/07/26/终端录制神器/","text":"使用showterm对终端脚本进行录制安装 如果是Mac用户，直接使用如下命令即可安装(默认情况下，Mac OS X 系统已经安装好 Ruby): 1gem install showterm 如果是Linux用户，可使用如下方式安装: 12curl showterm.io/showterm &gt; /usr/local/bin/showtermchmod +x /usr/local/bin/showterm 安装完毕之后便可以对终端进行录制了，录制后的结果是一个视频文件，并且为你自动生成一个可以公开访问的地址，非常方便； 验证是否安装成功： 1showterm -h 如果显示此工具使用方法，则说明安装成功！ 使用方法 打开终端，输入showterm，此时showterm会提示您正在进行脚本视频录制，如： 1showterm recording. (Exit shell when done.) 当你脚本录入完毕后，此时便可以使用exit命令结束本次录制。此时你会得到以下类似提示： 123showterm recording finished.Uploading...http://showterm.io/44c650714d8a45b265064 此时打开http://showterm.io/44c650714d8a45b265064 链接便可以对刚才的脚本操作进行显示！","tags":[{"name":"工具","slug":"工具","permalink":"http://baiwenhui.com/tags/工具/"},{"name":"终端","slug":"终端","permalink":"http://baiwenhui.com/tags/终端/"},{"name":"showterm","slug":"showterm","permalink":"http://baiwenhui.com/tags/showterm/"}]},{"title":"IDEA Mac下快捷键奇淫技巧","date":"2017-07-22T13:59:00.000Z","path":"2017/07/22/IDEA-Mac下快捷键奇淫技巧/","text":"为你的ide设置背景图片；只需要双击enter键，然后输入set back， 找到Set Background Image 选择你想要添加的背景图片即可。如果不需要设置图片，再次打开单击clear按钮即可清除。 若果你想展示自己点击的按钮快捷键，可以安装Presentation Assistant即可，安装完之后需要重启。 如果你想快速跳到某一个类的某一行，那么你可以使用Command+O,然后键入你想要跳转的类名称，然后输入冒号加行号； 如果你想看到你进入这个类中总共有哪些方法，你可以使用Command+7，此时便可以显示这个类中的所有方法； 如果你想找到某个类中的某个字段，你可以使用Command+Option+O,然后通过”/id”的方式，就可以找到所有包含id属性的类； 如果你想查看某个类中的变量或者方法在哪儿使用，直接使用Command+B即可； 如果你想查看某个变量的引用定义详情，则可以选中这个变量，然后使用Command+Y； 如果你想扩展左边项目结构窗口的大小，则可以使用Command+Shift+&gt;(右方向键)； 如果你想对编辑器某些窗口进行显示和隐藏，则可以双击Shift键，然后输入”#editor “,则可以对当前编辑器进行一些快速设置； 如果你想在idea中快速测试rest服务，则可以双击Shift然后输入test rest，找到最后一项打开rest test client便可以对服务进行测试调用； 如果你想双击Shift后，键入ws便可以打开test restful client tool，可以在keymap设置中输入test rest，找到Tools–Test Restful Webservice，然后选中右键选择Abbreviation设置ws，点击确定，然后双击Shift，输入ws，这时候第一项就是这个工具，此时便可以快速进入test restful client tool工具窗口； 如果你想对某个类进行全屏编辑，则可以使用Command+Shift+F12； 如果想快速打开项目结构视图，则可以使用Command+1； 如果你想对代码给别人展示或者review代码的时候，想放大某个类，则可以在view视图下选择：Enter Presenttion Mode即可，当然你也可以设置快捷键进行绑定，这个功能特别有用,比如我设置的是Command+Shift+S，这样当需要对某个文件进行展示时，直接按快捷键即可，在Presenttion Mode窗口中，我们可以使用Command+E显示最近浏览的文件，可以快速切换展示； 编辑器垂直分割和水平分割可以在菜单来Window下的edit tab中找到并绑定对应的快捷键； 当选择一行或者某个列时，使用option+上下方向键，不要使用鼠标勾选的方式； 如果你使用了两次以上剪贴操作，你想查看前几次的剪贴内容，则可以使用Commad+Shift+V,此时便可以找到前几次的剪贴记录； 如果你选择了某一行，想向上下选取，则使用option+上下方向键后，可以再使用shift+option+上下方向键； 当你需要对代码样式进行一些改变时，则可以选中代码片段 然后使用option+Enter； 如果你想在某个包下面建立一个类，你可以使用Command+上方向键激活导航bar，然后选择相应的目录，然后使用Command+N,新建你需要新建的类型即可，不要使用鼠标选择File新建，这样会影响效率； 如果不想在view中显示navbar，则可以设置navbar隐藏，方法：双击shift，输入nav，找到view navigation bar 选择off，然后使用Command+向上方向键便可以激活navbar； 如果你想使用BufferReader读取一个文件，此时你键入BufferReader bf = new的时候可以使用shift+option+space智能导入其派生类，由于 shift+option+space快键键可能会和输入法切换会有冲突，我设置成了shift+option+command+space； 如果你想在idea中引入包或者包裹异常，则可以使用option+Enter； 如果你想要对某个变量进行NPE验证，那么只需要使用这个变量名打”.”然后输入not，这时候选择相应的代码模板即可； 如果你想在代码的末尾添加分号，不要移动光标添加，直接使用shift+command+回车即可； 如果你想手写一个简单的JSON，可能需要使用转义字符进行转义双引号，此时你可以在字符串中使用option+回车选择Inject language reference选择JSON，然后再次使用option+回车键，选择Edit Json Fragement即可，此时你便可以在JSON 窗口中按照正常的方式编写JSON字符串了，IDE会自动帮你添加转义字符；同样的方式我们可以选择Regex，对正则进行编写，并且可以帮我们进行对正则校验，使用方法和JSON 输入的方式类似； 如果需要多行选中，则可以使用option+shift+鼠标点击 即可，或者可以使用control+G,然后继续选择你需要多行同时编辑的行，如果选择的行数多了，可以使用control+shift+g进行减少选中； 如果需要对选中的变量或者代码片段进行重构，则可以使用control+T； 对bool参数值进行转换，则可以对定义的bool变量选中然后使用control+T，输入invert，找到invert boolean，便可以对变量的值进行反转； 如果想对项目进行版本控制管理，使用Command+K或者使用Ctrl+V； 使用control+tab可以进行对不同的文件进行选择显示打开； 如果你想查看你目前使用快捷键的情况，则可以在idea的help菜单找到Poductivity Guide查看；注意：以上快捷键主要是Mac系统下的操作，如果你使用的是非Mac系统，那么你只需要安装Presentation Assistant便可以显示Linux和Windows上的快捷键如果想深入学习，可以参考该视频链接：https://www.youtube.com/watch?v=M2eL5YuqecQ&amp;list=PLQ176FUIyIUYUuSwE--flZWw2hfI21SjF&amp;index=2","tags":[{"name":"IDEA,Mac快捷键","slug":"IDEA-Mac快捷键","permalink":"http://baiwenhui.com/tags/IDEA-Mac快捷键/"}]},{"title":"使用springdata操作es出错org.elasticsearch.client.transport.NoNodeAvailableException","date":"2017-07-21T01:48:10.000Z","path":"2017/07/21/使用springdata操作es出错org-elasticsearch-client-transport-NoNodeAvailableException/","text":"之前的项目中使用的是http-client操作es，比较轻量级。目前为了学习下springdata，使用Java API 的方式来操作ES，但是在引入SpringData的es模块依赖后，操作es并未成功，出现以下错误：1org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [&#123;#transport#-1&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;] 注意：如果你下载elasticsearch的压缩包安装的话，可能不会出现该问题！因为es默认的配置文件cluster.name是elasticsearch。但是奇葩的是使用brew安装es之后，默认的elasticsearch.yml的配置项成了这样：cluster.name: elasticsearch_bwh，就是这个原因导致了这个问题的产生，项目启动后控制台一直抛这个错：1transport#-1&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125; not part of the cluster Cluster [Assassin], ignoring... 当执行添加操作时，提示：1org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [&#123;#transport#-1&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;] 最后需要注意的是，如果你修改了es默认的集群名称，则需要在src/main/resources/application.properties配置文件中进行指定： spring.data.elasticsearch.clusterName=elasticsearch_bwh通过源码org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchProperties可以看到，默认的clusterName为elasticsearch。 希望可以帮助遇到此类问题的同学。","tags":[{"name":"SpringData","slug":"SpringData","permalink":"http://baiwenhui.com/tags/SpringData/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://baiwenhui.com/tags/Elasticsearch/"}]},{"title":"hexo将多说替换为畅言","date":"2017-05-30T02:46:11.000Z","path":"2017/05/30/hexo将多说替换为畅言/","text":"由于多说团队在2017年6月1号停止了对多说的运营，因此需要将博客中使用的多说替换为畅言。 具体替换办法如下： 如果你没有畅言的账号，则首先去畅言的官网进行注册账号：畅言网址: http://changyan.kuaizhan.com/ 如果你已经注册过畅言的账号了，那么请直接登录即可； 注册登录成功之后，点击进入后台，如图,可以看到已经有APP ID和APP KEY，这两个字符串，等会在配置的时候需要： 由于我使用的是hexo的Yilia主题，这里以Yilia主题为主，进行下面的配置，其他主题类似。在畅言后台找到 安装畅言 点击展开之后，点击 通用代码安装 ，然后点击右边的复制代码，如图： 然后编辑你hexo目录下的themes/yilia/layout/_partial/post/duoshuo.ejs文件，将duoshuo.ejs中原来的内容全部删除，使用刚才拷贝的代码替换，替换后的样例如下： 12345678910&lt;!-- 畅言评论框 start --&gt;&lt;div id=&quot;SOHUCS&quot; sid=&quot;&lt;%=title %&gt;&quot; style=&quot;padding: 0px 30px 0px 46px;&quot;&gt;&lt;/div&gt;&lt;!-- 畅言评论框 end --&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function()&#123; var appid = &apos;你的appid&apos;; var conf = &apos;你的app key&apos;; var width = window.innerWidth || document.documentElement.clientWidth; if (width &lt; 960) &#123; window.document.write(&apos;&lt;script id=&quot;changyan_mobile_js&quot; charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=&apos; + appid + &apos;&amp;conf=&apos; + conf + &apos;&quot;&gt;&lt;\\/script&gt;&apos;); &#125; else &#123; var loadJs=function(d,a)&#123;var c=document.getElementsByTagName(&quot;head&quot;)[0]||document.head||document.documentElement;var b=document.createElement(&quot;script&quot;);b.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);b.setAttribute(&quot;charset&quot;,&quot;UTF-8&quot;);b.setAttribute(&quot;src&quot;,d);if(typeof a===&quot;function&quot;)&#123;if(window.attachEvent)&#123;b.onreadystatechange=function()&#123;var e=b.readyState;if(e===&quot;loaded&quot;||e===&quot;complete&quot;)&#123;b.onreadystatechange=null;a()&#125;&#125;&#125;else&#123;b.onload=a&#125;&#125;c.appendChild(b)&#125;;loadJs(&quot;https://changyan.sohu.com/upload/changyan.js&quot;,function()&#123;window.changyan.api.config(&#123;appid:appid,conf:conf&#125;)&#125;); &#125; &#125;)(); &lt;/script&gt; 然后就可以使用畅言了 由于我的域名已经备案，没有遇到网上说的不能正常加载畅言的方式，如果你的域名没有备案，具体Hacker方法，请参考：http://ev1l.cn/2017/05/13/changyancrack/ 注意： 如果你在配置中还有其他问题，欢迎打赏提问，我收到之后会快速帮你解决！","tags":[{"name":"Tools","slug":"Tools","permalink":"http://baiwenhui.com/tags/Tools/"}]},{"title":"递归的执行原理浅析","date":"2017-05-29T15:48:17.000Z","path":"2017/05/29/递归原理解析/","text":"首先使用递归输出经典的阶乘，描述如下： 1! =1 2! = 2 3! = 6… 接下来使用常规的递归方式实现（Java），则可以得到以下程序：1234567891011121314/** * Java普通递归实现阶乘 * * @param n 传递的大于0的正整数 * @return 该数字的阶乘 如：传递3 则计算 1 * 2 * 3 = 6 * 递归的核心思想自我理解： 先入栈计算直到递归终止 然后出栈 对每个栈中的值进行计算 最后得到结果 */ public static int factorial(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125; &#125; 递归调用示意图此递归的计算原理主要是先申请栈幁1到栈幁n，直到找到递归终止的条件，然后开始汇总结果，最后出栈，返回结果，这种递归算法方式有一个弊端，就是在计算的过程中当n很大的情况下会出现栈溢出的错误（java.lang.StackOverflowError），可以使用尾递归的方式进行优化，比如：1234567891011121314151617181920/** * 使用尾递归进行计算阶乘 * * @param n 需要计算的n的阶乘 * @param result 返回n的阶乘结果 如： 传递3 则计算 1 * 2 *3 = 6 * 计算过程如下： tailFactorial(3,1) * = tailFactorial(2,3*1) * = tailFactorial(1,2*3*1) * = tailFactorial(1,6) * = 6 * 揭秘：只使用一个栈幁就可以搞定计算 * @return 返回n的阶乘 */ public static int tailFactorial(int n, int result) &#123; if (n == 1) &#123; return result; &#125; else &#123; return tailFactorial(n - 1, n * result); &#125; &#125; 计算a,b（a,b为非负整数）的最大公约数？此题目可以使用欧几里得算法进行解答，实现代码如下：1234567891011121314/** * 欧几里得算法计算两个数的最大公约数 * @param p 需要计算的数a * @param q 需要计算的数b * @return 返回a，b的最大公约数 a,b 是大于0 的正整数 * 算法描述： 计算两个非负整数的最大公约数： 若q是0，则最大公约数为p。否则，将p除以q得到余数r，p和q的最大公约数则为q和r的最大公约数 */ public static int greatestCommonDivisors(int p , int q)&#123; if(q==0)&#123; return p; &#125; int r = p % q; return greatestCommonDivisors(q,r); &#125; 最后我们开始使用递归遍历某个目录下的所有子目录和文件进行加深理解和运用：123456789101112131415161718192021222324public static void printDirectoriesAndFilesByPath(String path) &#123; try &#123; File file = new File(path); if (file.exists()) &#123; File[] files = file.listFiles(); for (File f : files) &#123; if (f.isDirectory() &amp;&amp; f.listFiles().length &gt;= 0) &#123; if (f.isDirectory()) &#123; String directory = f.getAbsolutePath(); System.out.println(\"-------目录名称:\" + f.getAbsolutePath()); printDirectoriesAndFilesByPath(directory); &#125; &#125; else &#123; System.out.println(\"-------目录名称:\"+f.getParent()+\"---&gt;文件名称：\" + f.getAbsolutePath()); &#125; &#125; &#125; else &#123; System.out.println(\"对不起，文件路径不存在\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;","tags":[{"name":"DataStructureAndAlgorithm","slug":"DataStructureAndAlgorithm","permalink":"http://baiwenhui.com/tags/DataStructureAndAlgorithm/"}]},{"title":"SpringBoot学习一","date":"2017-03-12T15:42:17.000Z","path":"2017/03/12/SpringBoot学习一/","text":"SpringBoot Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 遵循建立生产就绪Spring应用程序的观点。SpringBoot支持约定优于配置的惯例，旨在让您尽快启动和运行。 Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. SpringBoot可以轻松的创建单独的，生产级的基于Spring的应用，您可以“直接运行”。我们为Spring平台和第三方库提供了开箱即用的设置，这样你就可以有条不斋的开始。大多数的SpringBoot程序只需要很少的Spring配置。 Features Create stand-alone Spring applications Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) Provide opinionated ‘starter’ POMs to simplify your Maven configuration Automatically configure Spring whenever possible Provide production-ready features such as metrics, health checks and externalized configuration Absolutely no code generation and no requirement for XML configuration 功能 创建标准独立的Spring应用程序 直接嵌入Tomcat、Jetty或者Undertow（不需要部署WAR文件） 提供建议的‘starter’POM模板以简化您的Maven配置 每当可能时自动配置Spring 提供生产就绪的功能，如指标，运行状况检查和外部化配置 绝对没有代码生成和不需要XML配置 The reference guide includes detailed descriptions of all the features, plus an extensive howto for common use cases.该参考指南包含所有功能的详细说明，以及广泛的如何使用共同使用情况。 Quick StartIf you are Java developer you can use start.spring.io to generate a basic project, follow the “Quick Start” example below, or read the reference documentation getting started guide. 快速开始如果你是一名Java程序员，你可以通过start.spring.io生成基本项目，按照下面的“快速开始”示例或者阅读参考文档的入门指南。 The recommended way to get started using spring-boot in your project is with a dependency management system – the snippet below can be copied and pasted into your build. Need help? See our getting started guides on building with Maven and Gradle. spring-boot在项目中开始使用的推荐方法是使用依赖关系管理系统 - 下面的代码段可以复制并粘贴到您的构建中。需要帮忙？请参阅我们使用Maven和 Gradle构建的入门指南。 Maven1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle123dependencies &#123; compile(&quot;org.springframework.boot:spring-boot-starter-web:1.5.1.RELEASE&quot;)&#125; 1hello/SampleController.java 123456789101112131415161718192021package hello;import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@Controller@EnableAutoConfigurationpublic class SampleController &#123; @RequestMapping(&quot;/&quot;) @ResponseBody String home() &#123; return &quot;Hello World!&quot;; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125; Spring Boot CLISpring Boot ships with a command line tool that can be used if you want to quickly prototype with Spring. It allows you to run Groovy scripts, which means that you have a familiar Java-like syntax, without so much boilerplate code. Follow the instructions in our main documentation if you want to install the Spring Boot CLI. Spring Boot 命令行工具Spring Boot附带一个命令行工具，如果你想快速使用Spring原型，可以使用它。它允许你运行Groovy脚本，这意味着你有一个熟悉的类似Java的语法，没有那么多的样板代码。如果要安装Spring Boot CLI，请按照我们的主要文档中的说明进行操作。","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://baiwenhui.com/tags/SpringBoot/"}]},{"title":"Java面试(一)","date":"2017-03-04T16:04:28.000Z","path":"2017/03/05/Java面试-一/","text":"Java基础抽象类和接口的区别？ 抽象类中可以包含抽象方法和非抽象方法，接口只能包含公开的抽象方法； 抽象类中的变量是各种类型的，而接口只能包含public abstract final 类型； 接口中不能含有静态代码块和静态方法，而抽象类中可以包含； 一个类只能继承一个抽象类，但是可以实现多个接口； 抽象类可以有构造方法，接口不能有； HashMap和HashTable的区别？ HashTable是基于陈旧的Dictionary的Map接口的实现，而HashMap是基于哈希表的Map接口的实现 从方法上看，HashMap去掉了HashTable的contains方法 HashTable是同步的（线程安全），而HashMap是线程不安全的，效率上HashMap更快 HashMap允许空键值，HashTable不允许，可以查看HashTable的实现源码： 12345678910111213141516171819202122232425...public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125;... HashMap的iterator迭代器执行快速失败机制，也就是说在迭代过程中修改集合结构，除非调用迭代器自身的remove方法，否则以其他任何方式的修改都将抛出并发修改异常。而Hashtable返回的Enumeration不是快速失败的。 Java中如何创建一个新线程？ 实现runable接口并重写run方法； 继承Thread类重写run方法； 实现Callable接口，重写call()方法；使用FutureTask类包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值；使用FutureTask对象作为Thread对象的target创建并启动线程，调用FutureTask对象的get()方法获得子线程执行结束后的返回值； 什么是AIDL？ AIDL全称Android Interface Definition Language（AndRoid接口描述语言）是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程跨界对象访问的目的.AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。 AIDL支持的数据类型有Stirng，list，map，All native java datatype 求计算1-2+3-4+5-6…的方法，n很大，考虑性能？1234567891011121314151617181920212223public static long fn(long n) &#123; if(n&lt;=0) &#123; //1-2+3-4+5-6 当n为负数时，结果肯定为负数,使用加法结合律得出当n为偶数时,结果为(1-2)+(3-4)...(-1)+(-1),规律 //当n为2时，结果为一个-1和，当n为4时，结果为2个-1的和,由此得出此结果的规律为(-1)*(n/2) //当n为奇数的时候，当n为1时，结果为1，当n为3时候,结果为2,当n为5时候,结果为3... //由此得出规律应该为：(-1)*(n/2)+n =-n/2+n 或者 (n+1)/2 //&gt;&gt;(右移) //操作数每右移一位，相当于该数除以2 System.out.println(&quot;error&quot;); return 0; &#125; if(0==n%2) return (n&gt;&gt;1)*(-1); else&#123; System.out.println(&quot;aaa&quot;); return (n&gt;&gt;1)*(-1)+n; //或者可以替换为(n+1)&gt;&gt;1; &#125; &#125; char类型的取值范围：0-216-1 Java中如何在线程中返回一个值？答案：可以让这个类去实现Callable接口，然后定义私有变量进行传递即可：如，1234567891011121314151617181920212223package com.pff;import java.util.concurrent.Callable;/** * Created by strongant on 16-6-16. */public class MutiThread implements Callable&lt;String&gt; &#123; private String str; private int count = 1; public MutiThread(String str) &#123; this.str = str; &#125; //需要实现的CallAble的Call方法 public String call() throws Exception &#123; for (int i = 0; i &lt; this.count; i++) &#123; System.out.println(&quot;Callable的call()方法打印:&quot; + this.str + &quot; &quot; + i); &#125; return this.str; &#125;&#125; 测试调用1234567891011121314151617181920212223242526272829303132package com.pff;import java.util.ArrayList;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * Created by strongant on 16-6-16. */public class CallableTest &#123; public static void main(String[] args) &#123; //创建一个线程池 ExecutorService exs = Executors.newCachedThreadPool(); ArrayList&lt;Future&lt;String&gt;&gt; al = new ArrayList&lt;&gt;(); al.add(exs.submit(new MutiThread(&quot;String0&quot;))); for (Future&lt;String&gt; fs : al) &#123; try &#123; System.out.println(fs.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; exs.shutdown(); /*第二种方式，使用FutureTask来接收线程的返回值 MutiThread task = new MutiThread(&quot;test&quot;); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(task); Thread thread = new Thread(futureTask); thread.start(); */ &#125;&#125; 具体流程就是实现Callable 泛型接口，然后线程类定义私有变量，重写call()方法，并且返回Callable接口声明的泛型类型值即可； 获取的时候使用Future泛型类去使用Future类的get()方法就可以获取到；","tags":[{"name":"Java面试","slug":"Java面试","permalink":"http://baiwenhui.com/tags/Java面试/"}]},{"title":"2017开工快乐","date":"2017-02-05T13:43:05.000Z","path":"2017/02/05/2017开工快乐/","text":"春节已经结束了，祝愿大家在新的一年多挣钱！在这里给大家分享一份简历模板：http://resume.f-tm.net/ 简历开源地址:https://github.com/googlerobot/resume","tags":[{"name":"随笔","slug":"随笔","permalink":"http://baiwenhui.com/tags/随笔/"}]},{"title":"春节回家","date":"2017-01-23T13:20:53.000Z","path":"2017/01/23/春节回家/","text":"对于刚过去不远的2016年，有欢乐，有辛酸，有失望，有快乐！还记得自己2016年年初的时候计划通过自己的努力买一台MakBook Pro（非正式工资的钱买），可到头来并没有完成我的这个愿望！ 远在他乡的我，随着年龄的增长，感到些许压抑、彷徨和不安，在新的2017年我决定奋力冲刺，早日实现自己的梦想！ 远在他乡，来到陌生的城市，看着天天上涨的房价，买房这件事情也只能想想。自己长大了，父母却老了，他们需要我们的照顾，在一线城市上几年班，攒个首付去二三线城市买一套房子然后打拼事业，这也是我的打算！乘着二三线城市的房价还没有大幅上涨，还是早下手为强！ 在一线城市上班，别人听起来工资很高，经常听到隔壁阿姨说：谁谁家的儿子在哪哪呢，一个月挣1W多呢，可是花销完，房租缴完，也剩不下多少钱了。要想拿到更多的薪水，就得从自身开始做起。我已经为自己制定好了2017年的计划，你呢？ 在这里，提前祝大家新年快乐！以上是我的一点生活感触，博客地址：http://baiwenhui.com，欢迎交流、分享：","tags":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://baiwenhui.com/tags/生活感悟/"}]},{"title":"rxjs翻译-rxjs介绍","date":"2017-01-22T13:26:40.000Z","path":"2017/01/22/rxjs翻译-rxjs介绍/","text":"介绍RxJS是一个基于可观察对象(Observable)序列，用于异步或者事件编程的库。它提供一个核心类型，Observable ，几个卫星类型（Observer, Schedulers, Subjects）以及一些由Array#extras (map, filter, reduce, every等)激发的，让异步事件可以以集合的方式被处理的运算子(Operators)。 可以将RxJS想象成是用于处理事件的Lodash. ReactiveX将Observer模式和Iterator模式和对集合进行函数式编程结合起来，从而满足了对事件序列进行管理的需求。 RxJS用于解决异步事件的管理问题，它的核心概念如下： Observable: 代表数据与事件的集合，这个集合可以被调用，从而可以生成数据和事件。 Observer: 回调函数的集合，用于获取想要数据。这些数据来自于Observable。 Subscription: 用于表示Observable的执行状态，主要用于执行的取消。 Operator: 函数式风格的纯函数，通过map, filter, concat, flatMap等操作对集合进行处理。 Subject: 与EventEmitter等价，唯一可以将一个值或者事件向个多个Observer进行广播的办法。 Schedulers: 一个中心化的、控制并发的分发器，允许我们可以在象setTimeout、requestAnimationFrame或者其它类似的计算中可以进行调整。 第一个例子通常你是这样注册事件的侦听器(listener)的。12var button = document.querySelector('button');button.addEventListener('click', () =&gt; console.log('Clicked!')); 使用RxJS的话，你要创建一个Observable来替换。 123var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .subscribe(() =&gt; console.log('Clicked!')); 纯粹(Purity)让RxJS强大的是它能完全通过函数来生成数值，这也就意味着可以减少代码出错的机会。 通常你会创建比较不纯粹的函数，在这样的函数里，其它的代码片段会让你的状态变的混乱。 123var count = 0;var button = document.querySelector('button');button.addEventListener('click', () =&gt; console.log(`Clicked $&#123;++count&#125; times`)); 而使用RxJS可以将你的状态进行隔离。 译者注： 指count不再需要定义在外面。 1234var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .scan(count =&gt; count + 1, 0) .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`)); 这里scan运算子的工作方式与reduce在数组里的工作方式是一样的。它从传给回调函数的值中获取值。返回的值将会作为下一次的传入值。 译者注：scan第二个参数0是初始值。对于上面的函数来说就可以用来侦听被点击的次数了，非常的方便。 流转（Flow）RxJS有一堆的运算子可以帮助你控制事件如何在你的可观察对象里流转。 下面是你在纯JavaScript下允许一分钟最多一次点击的代码： 12345678910var count = 0;var rate = 1000;var lastClick = Date.now() - rate;var button = document.querySelector('button');button.addEventListener('click', () =&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; console.log(`Clicked $&#123;++count&#125; times`); lastClick = Date.now(); &#125;&#125;); 使用RxJS后: 12345var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .throttleTime(1000) .scan(count =&gt; count + 1, 0) .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`)); 其实的流转控制运算子还有filter, delay, debounceTime, take, takeUntil, distinct, distinctUntilChanged等。 值(Values)你可以转化赋给你的观察者的值。 下面是你在纯JavaScript下添加当前鼠标的每个点击事件的x轴位置的代码： 1234567891011var count = 0;var rate = 1000;var lastClick = Date.now() - rate;var button = document.querySelector('button');button.addEventListener('click', (event) =&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; count += event.clientX; console.log(count) lastClick = Date.now(); &#125;&#125;); 使用RxJS后: 123456var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .throttleTime(1000) .map(event =&gt; event.clientX) .scan((count, clientX) =&gt; count + clientX, 0) .subscribe(count =&gt; console.log(count)); 另外几个用于生成值的运算子有pluck, pairwise,sample等。 译者注：这里map可以将事件里的值取出来，如果不进行map，clientX里的值就是事件本身。这里要注意的是每次变换，其实对象是发生变化的。subscribe一次之后就不能再subscribe了。","tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://baiwenhui.com/tags/rxjs/"}]},{"title":"修正browser-sync公众号文章的错误","date":"2017-01-21T14:30:29.000Z","path":"2017/01/21/修正browser-sync公众号文章的错误/","text":"首先说说声对不起，在上一篇的公众号文章：《放弃F5，拥抱browser-sync》中存在几个错误点。链接地址: https://mp.weixin.qq.com/s?__biz=MzAxMDgyOTgwOQ==&amp;mid=2247483709&amp;idx=1&amp;sn=9939c3029c12ef1f716111cd0c9e9ffc&amp;chksm=9b4b2ba3ac3ca2b5dea5496d6f9d87d7a0218ed85e4f807d4da2374957dd1b64cea234d5074c&amp;mpshare=1&amp;scene=1&amp;srcid=0228DCwqHbO5bJNRzdNcoQaJ&amp;key=1ffbac7579ea006ba638f1c527ceb6fccc5cd60675bb72cb4ac4e1669f8844ac48f5c811613c0700f5b5a5d0758631cddccd09a62852836bbe7ea0a2f3b6519205a05d50a53e595fa3c414a39a8f507f&amp;ascene=0&amp;uin=MTkwMTU1MzgyMw%3D%3D&amp;devicetype=iMac+Macmini7%2C1+OSX+OSX+10.12.3+build(16D32)&amp;version=12020010&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=iTAw5XKKAiEh5rRG8zKg5HPSatL3GYf2%2FVDBxyBOTnbVmCeOf%2FgW%2FmhS5DctS64z 几个错误点修改如下： 文章中的：……更重要的是 Browsersync可以同时在PC、平板、手机等设备下进项调试…将“进项调试”修改为“进行调试”2. 最后的代码有一个目录错误，因为我的粗心，给大家带来的不变，请见谅！在以后的文章中我会更加小心发表文章，力求保证没有错误！1234567891011121314151617181920212223242526272829var gulp = require(&apos;gulp&apos;);var browserSync = require(&apos;browser-sync&apos;).create();var browserify = require(&apos;gulp-browserify&apos;);var sass = require(&apos;gulp-sass&apos;);var uglify = require(&apos;gulp-uglify&apos;);// Compile sass into CSS &amp; auto-inject into browsersgulp.task(&apos;sass&apos;, function() &#123; return gulp.src(&quot;app/scss/*.scss&quot;) .pipe(sass()) .pipe(gulp.dest(&quot;dist/css&quot;)) .pipe(browserSync.stream());&#125;);// process JS files and return the stream.gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;app/js/*.js&apos;) .pipe(browserify()) .pipe(uglify()) .pipe(gulp.dest(&apos;dist/js&apos;));&#125;);// Static Server + watching scss/js/html filesgulp.task(&apos;serve&apos;, [&apos;sass&apos;,&apos;js&apos;], function() &#123; browserSync.init(&#123; server: &quot;./app&quot; &#125;); gulp.watch(&quot;app/scss/*.scss&quot;, [&apos;sass&apos;]); gulp.watch(&quot;app/js/*.js&quot;, [&apos;js&apos;]); gulp.watch(&quot;app/*.html&quot;).on(&apos;change&apos;, browserSync.reload);&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 修改为：1234567891011121314151617181920212223242526272829var gulp = require(&apos;gulp&apos;);var browserSync = require(&apos;browser-sync&apos;).create();var browserify = require(&apos;gulp-browserify&apos;);var sass = require(&apos;gulp-sass&apos;);var uglify = require(&apos;gulp-uglify&apos;);// Compile sass into CSS &amp; auto-inject into browsersgulp.task(&apos;sass&apos;, function() &#123; return gulp.src(&quot;app/scss/*.scss&quot;) .pipe(sass()) .pipe(gulp.dest(&quot;.app/dist/css&quot;)) .pipe(browserSync.stream());&#125;);// process JS files and return the stream.gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;app/js/*.js&apos;) .pipe(browserify()) .pipe(uglify()) .pipe(gulp.dest(&apos;.app/dist/js&apos;));&#125;);// Static Server + watching scss/js/html filesgulp.task(&apos;serve&apos;, [&apos;sass&apos;,&apos;js&apos;], function() &#123; browserSync.init(&#123; server: &quot;./app&quot; &#125;); gulp.watch(&quot;app/scss/*.scss&quot;, [&apos;sass&apos;]); gulp.watch(&quot;app/js/*.js&quot;, [&apos;js&apos;]); gulp.watch(&quot;app/*.html&quot;).on(&apos;change&apos;, browserSync.reload);&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 参照对比原文地址： https://mp.weixin.qq.com/s?__biz=MzAxMDgyOTgwOQ==&amp;mid=2247483709&amp;idx=1&amp;sn=9939c3029c12ef1f716111cd0c9e9ffc&amp;chksm=9b4b2ba3ac3ca2b5dea5496d6f9d87d7a0218ed85e4f807d4da2374957dd1b64cea234d5074c&amp;mpshare=1&amp;scene=1&amp;srcid=0228DCwqHbO5bJNRzdNcoQaJ&amp;key=1ffbac7579ea006ba638f1c527ceb6fccc5cd60675bb72cb4ac4e1669f8844ac48f5c811613c0700f5b5a5d0758631cddccd09a62852836bbe7ea0a2f3b6519205a05d50a53e595fa3c414a39a8f507f&amp;ascene=0&amp;uin=MTkwMTU1MzgyMw%3D%3D&amp;devicetype=iMac+Macmini7%2C1+OSX+OSX+10.12.3+build(16D32)&amp;version=12020010&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=iTAw5XKKAiEh5rRG8zKg5HPSatL3GYf2%2FVDBxyBOTnbVmCeOf%2FgW%2FmhS5DctS64z 目前内容已经修改！欢迎反馈，欢迎交流：","tags":[]},{"title":"hexo搭建成功","date":"2017-01-19T15:20:52.000Z","path":"2017/01/19/hexo搭建成功/","text":"终于折腾完了，搭建好我的hexo，的确挺方便的！感谢前人的贡献！","tags":[]}]