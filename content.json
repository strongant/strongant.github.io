[{"title":"分布式定时任务XXL-JOB在我司的选型","date":"2020-09-16T15:39:44.000Z","path":"2020/09/16/分布式定时任务XXL-JOB在我司的选型/","text":"任务系统任务 什么时间 什么地点 做什么事 一个简单的任务 cron 早期的 cronV7，1979 在Version 7 Unix里是一个系统服务 只用 root 运行任务 算法简单直接 更多详情请参考: https://en.wikipedia.org/wiki/Cron 早期的 cron 运行逻辑 读 /usr/lib/crontab 文件 如果有命令要在当前时间执行，就用 root 用户去执行命令 Sleep 1 minute 重新从步骤 1 开始 支持多用户的 cronUnix System V，1983 启动的时候读取所有用户下的 .crontab 文件 计算出每个 crontab 文件里需要执行的命令的下一次执行时间 把这些命令按下一次执行时间排序后放入队列里 进入主循环① 计算队列里第一个任务的执行时间与当前的时间差② Sleep 直到第一个任务执行时间③ 后台执行任务④ 计算这个任务的下一次执行时间，放回队列，排序 近代的 cronLinux，1991 Vixie cron(Paul Vixie 1987) Version 3 Vixie cron(1993) Version 4.1 ISC Cron(2004) anacron, dcron, fcron cron 的局限性 单机 无界面 功能比较简单 多机器的情况下任务维护成本较高 分布式任务系统分布式系统的特点 分布性 对等性(没有控制系统的主机, 也没有被控制的从机) 并发性 缺乏全局时钟(缺乏全局时钟序列控制) 故障总是会发生 分布式 cron 我只是不爱动，不是懒 分布式系统对任务调度的几点要求1、平台：快速开发、业务复用、自维护和扩展；2、HA/集群：避免单点故障，发挥集群优势3、弹性扩缩：适应业务快速发展4、故障处理：Failover、失败告警5、阻塞处理：耗时任务阻塞5、⾼性能：调度和任务解耦，全异步化6、自运维：自助维护、实时监控、快速了解任务进展 我眼里的“西施” 可替代 cron 分布式、高可用 支持多种任务属性 易用 易部署 为什么选择使用 XXL-JOB 项目中有这样的需求：需要使用定时器从 A 和 B 系统中同步不同的表中的数据，并且对数据进行一定的加工处理，最后将最终的数据写入到数据仓库DB，需要实现针对不同的数据源进行配置（这块也就是多数据源的支持），任务配置可以根据任务量的大小使用不同的资源。对数据同步的时效性和性能要求非常高，并且这些定时任务可以通过页面配置的方式做到灵活，可控制。 通过以上的这些需求，我们对目前业界比较流行的任务调度框架进行了技术选型，通过研究发现，目前使用比较广泛的任务调度框架有 XXL-JOB 和 Elastic-JOB ，因此，参考 XXL-JOB 官方对不同任务调度平台的比对，如下图所示： 针对以上对比，我们选择了 XXL-JOB 任务调度框架，因为它相比于其他任务调度框架来说，具有更好的用户体验、有良好的运维支持、任务依赖、任务路由原生支持，通过调研发现，框架自带的任务路由策略已经满足我们的业务场景，并且支持分片任务，当任务延迟较高时，可以利用分片的方案加速任务的处理。 XXL-JOB 介绍 XXL-JOB是⼀个轻量级分布式任务调度框架。拥有“HA、弹性扩缩、故障处理、阻塞处理、⾼性能、自运维”等特点。其核⼼部分包括：1、调度模块（调度中⼼）：负责管理任务信息，触发任务执⾏，自身不承担业务逻辑；同时提供“日志、报表、告警、GLUE、注册中⼼”等功能；2、执⾏模块（执⾏器）： 负责接收调度中⼼请求，进⾏任务逻辑执⾏、终⽌、日志加载等操作；专注于任务执⾏相关操作； XXL-JOB 发展• 2015年中，着⼿设计XXL-JOB，提交第⼀个Commit• 2015-11月，发布首个Release版本，同期当选为开源中国月度热门项目• 2016-01月，我司展开定制和接⼊，⾄今调度近百万次• 2017-05-03，应邀参加“第62期开源中国源创会”现场分享XXL-JOB• 2017-10月，当选为开源中国首批GVP项目• ……• ⾄今，XXL-JOB登记接⼊公司50+（点评、移动、平安、海尔、优信），社区群8个，群成员约3000 ⼈ XXL-JOB 架构图 XXL-JOB 特性全览1、简单2、动态3、调度中心HA（中心式）4、执行器HA（分布式）5、任务Failover6、一致性7、自定义任务参数8、调度线程池9、弹性扩容缩容10、邮件报警11、状态监控12、Rolling执行日志13、GLUE：提供Web IDE14、数据加密15、任务依赖16、推送maven中央仓库17、任务注册18、路由策略19、运行报表20、脚本任务21、阻塞处理策略22、失败处理策略23、分片广播任务24、动态分片25、事件触发 HA/集群 弹性扩缩 执行器路由策略 故障转移 &amp; 忙碌转移 分片任务 &amp; 动态分片 阻塞策略 &amp; 失败处理策略 ###触发规则 Cron 表达式如：每日凌晨 2 点，进行“PV 数据计算”的任务 任务依赖触发如：父任务“PV 数据计算”执行结束后，触发多业务线的“PV 报表生成”的多个子任务 事件触发/API 服务如：类 MQ 场景，短信验证码、订单创建等。 任务模式1、BEAN 模式：JobHandler、Spring Bean2、GLUE 模式(Java )：Web IDE、在线开发、版本回溯、Java 语言、动态编译（IOC）、实时生效、Rolling Log3、GLUE 模式(Shell)：Web IDE、在线开发、版本回溯、实时生效、Rolling Log4、GLUE 模式(Python)5、GLUE 模式(NodeJS) （其中“GLUE 模式(NodeJS)”来源于 “icyblazek@github”同学提交的 PR，XXL-JOB 理论上支持任何类型脚本 语言的任务模式扩展） GLUE 模式 执行日志 &amp; Rolling Log XXL-JOB 搭建1、安装 Mysql，初始化 XXL-JOB 底层库表 • 2、编译部署“调度中心” • 3、编译部署“执行器”（参考多个 Sample 项目） 》》》开发第一个 JobHandler入门文档 （可参考文档 “快速入门”章节：）： http://www.xuxueli.com/xxl-job/","tags":[{"name":"分布式任务调度,xxl-job","slug":"分布式任务调度-xxl-job","permalink":"http://baiwenhui.com/tags/分布式任务调度-xxl-job/"}]},{"title":"ELK日志迁移技术分享","date":"2020-09-14T13:03:08.000Z","path":"2020/09/14/ELK日志迁移技术分享/","text":"日志处理方案演进1.1 什么是日志 日志是带时间戳的基于时间序列的机器数据，包括IT系统信息（服务器、网络设备、操作系统、应 用软件）、物联网各种传感器信息。日志反映用户行为，是事实数据，也是系统运维、故障诊断、性能分析的重要来源。对于任何系统，日志都是极其重要的组成部分。 1.2 日志处理的背景 随着大数据时代的来临，系统日志量也呈指数级增加。随着日志格式复杂度的增加、日志规模的扩大以及应用节点的增多，传统的日志量过大分析耗时耗力、效率低下、无法胜任复杂的统计分析等。并且传统的日志分析无法满足实时化分析的业务需求，实时化分析也是当今大数据技术的发展趋势之一。 1.3 日志处理方案演进 业界一般对日志的处理方案演进如下： 日志处理古老版 日志没有集中式处理，一般情况下手动到服务器上使用 Linux 命令排查日志；日志的唯一作用就是做故障之后的排查；使用数据库存储日志，无法胜任复杂的实时统计分析需求。 日志处理离线版 一般使用 Hadoop 平台实现日志的离线批量处理，缺点便是实时性太差； 也有使用 Storm 流处理框架、Spark 内存计算框架处理日志， Hadoop/Storm/Spark 都是编程框架，并不是拿来就可以使用的平台。 日志处理实时版 一般使用日志实时搜索引擎分析日志，其作为代表的解决方案主要有 Splunk(Splunk是一个分析计算机系统产生的机器数据，并在广泛的场景中提供数据收集、分析、可视化分布式的数据计算平台。)、ELK、EFK（EFK由ElasticSearch、Fluentd和Kiabana三个开源工具组成。Fluentd也是一个实时开源的数据收集器,）。 优点有什么？ 快速，日志从产生到搜索分析出结果只有数秒延时； 可以处理大量数据，每天可以处理 TB 级日志量； 很灵活，可以分析任何的实时日志。 其中，ELK 在业界最受欢迎，目前我们也使用的是ELK日志处理方案。ELK 是 Elastic 公司出品的开源实时日志处理与分析的解决方案，ELK 分别代表分布式搜索引擎 Elasticsearch、日志采集与解析工具 Logstash、日志可视化分析工具 Kibana，ELK日志处理方案具有配置灵活、集群可线性扩展、日志实时导入、检索性能高效、可视化分析方便等优点，已经成为业界日志处理方案的不二选择。 ELK 架构解读2.1 架构选择 完整的日志分析系统主要包括日志采集系统、日志解析系统、日志存储系统和可视化分析系统四部分组成。典型的 ELK 架构图如下所示： ELK 架构中，由于 Logstash 既作为日志搜集器又作为日志解析器，本身会消耗服务器较多的CPU 和 内存，如果服务器计算资源不够丰富，则会造成服务器性能下降无法正常工作。为了解决Logstash 占用系统资源高的问题，Elastic 公司推出了轻量级的日志采集器 Beats，在数据收集方面取代 Logstash，引入 Beats 后的系统架构如如下： Beats 是一系列采集器的总称，对于不同的日志源和日志格式可以使用不同的Beats，截止目前为止，Beats 家族包括以下 7 个成员： Filebeat：轻量级的日志采集器，可用于收集文件数据。 Metricbeat：5.0版本之前名为Topbeat，收集系统、进程和文件系统级别的 CPU 和内存使用情况等数据。 Packetbeat：收集网络流数据，可以实时监控系统应用和服务，可以将延迟时间、错误、响应时间、SLA性能等信息发送到Logstash或Elasticsearch。 Winlogbeat：Windows 事件日志 Heartbeat：运行时间监控。 Auditbeat: 审计日志数据采集。 Functionbeat：无需服务器的采集器。 目前对于日志规模较大的场景，还需要引入消息队列，Logstash 支持常用的消息队列有 Kafka、RabbitMQ、Redis等。引入消息队列后的架构如下： 2.2 日志采集模块分析 日志采集是对日志进行分析的基础，我们对于不同的日志类型可以选择不同类型的 beats。在我们的日常使用中，基本大多数情况以文件类型的日志居多，这里我们就以filebeat 采集文件类型的日志进行探索日志采集的原理。 FileBeat 是采用Go 语言由 Elastic 官方开发的轻量级日志采集器，在应用服务器上以代理的形式安装。当这个 FileBeat 进行启动时，它会启动一个 prospector 监控日志路径或者日志文件，每一个日志文件都会有一个对应的 harvester， harvester 按行读取日志内容并转发至后台程序。FileBeat 维护了一个记录文件读取信息的注册文件，记录每个 harvester 最后读取位置的偏移量。日志按行读取以后，转发至 logstash 做解析。 2.3 日志解析模块分析 Logstash是分布式数据收集引擎，在日志处理中担任搬运工的角色，它支持动态的从各种数据源搜集数据，并对数据进行过滤、分析、统一格式等操作，然后输出到用户指定的位置。事件流通过Logstash中的Input、Filter和Output插件处理和转换，Input用于配置日志的输入源，Filter用来解析日志，Output指定日志的输出去向。 Grok是Logstash的一个正则解析插件，它能对日志流进行解析，内置了120多种的正则表达式库，对日志解析时需要针对日志格式定义相应的正则表达式。结合Grok提供的便利，总结出按行读取文件格式日志的解析步骤： （1）首先对日志进行分析，明确每一个字段的含义，确定日志的切分规则，也就是一条日志切分成哪几个字段，这些字段是以后做日志分析的关键，对原始日志的解读和分析是非常关键的一步。 （2）根据步骤（1）的切分原则确定提取每一个字段的正则表达式，如果Grok中的正则库满足需求直接使用即可，否则采用自定义模式，两者可以组合使用。 （3）在Grok Debugger调试工具中调试、验证解析日志的正则表达式是否正确。 举一个例子，下面是一条半结构化日志： 12017-12-16 00:00:01,570 133382978 [ HandleConsumer.java:445:INFO ] 车辆号牌为空 对应的Grok表达式如下： 1%&#123;TIMESTAMP_ISO8601:time&#125;\\s*%&#123;NUMBER:bytes&#125;\\s*\\[\\s*%&#123;JAVAFILE:class&#125;\\:%&#123;NUMBER:lineNumber&#125;\\s*\\:%&#123;LOGLEVEL:level&#125;\\s*\\]\\s*(?&lt;info&gt;([\\s\\S]*)) 格式化后的日志如下： 12345678&#123; &quot;time&quot;: &quot;2017-12-16 00:00:01,570&quot;, &quot;bytes&quot;:&quot;133382978&quot;, &quot;class&quot;: &quot;HandleConsumer.java&quot;, &quot;lineNumber&quot;: &quot;445&quot;, &quot;level&quot;: &quot;INFO&quot;, &quot;info&quot;:&quot;车辆号牌为空。&quot;&#125; Grok Debugger调试正则表达式如图4所示： 2.4 日志存储模块分析 Elasticsearch是存储日志的中央系统，实际项目中，根据需求搭建Elasticsearch集群即可。 2.5 日志可视化模块分析 Kibana是一个开源日志分析及可视化平台，使用它可以对存储在Elasticsearch索引中的数据进行高效的搜索、可视化、分析等各种操作。Kibana的愿景是让海量数据更容易理解，通过浏览器的用户界面可以创建各种高级图表进行数据分析和展示，它的仪表盘功能可以汇总多个单操作图表，并且可以实时显示查询动态。","tags":[{"name":"elk,elasticsearch","slug":"elk-elasticsearch","permalink":"http://baiwenhui.com/tags/elk-elasticsearch/"}]},{"title":"使用Docker构建企业级自定义镜像","date":"2020-05-19T14:19:40.000Z","path":"2020/05/19/使用Docker构建企业级自定义镜像/","text":"前言 临下班前，楼主接到了一个需求，由于基础镜像标准发生变更，需要按照最新的Docker 镜像标准构建自己应用的自定义镜像。目前的标准是这样的：基础架构组只提供所有项目必须接入的3个公共镜像，这3个公共基础镜像包含了：JDK8、Skywalking、Arthas。对于各自业务组的应用如果还需要加入其它镜像，则由各个业务组自己基于基础架构组提供的公共镜像之上，再添加自定义的镜像，结构图如下： 构建步骤编写Dockerfile 基于最新的规范来看，我们需要编写一个Dockerfile，然后引用基础架构组提供的基础镜像，再加入应用需要的其他镜像。因此最终的 Dockerfile 文件如下： 123FROM 基础镜像地址RUN apk add 需要添加的自定义镜像... 在Centos7下安装Docker环境卸载旧版本较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装 Docker Engine-Community使用 Docker 仓库进行安装在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker。 设置仓库 安装所需的软件包。yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。 123$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 使用以下命令来设置稳定的仓库。 123$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装 Docker Engine-Community安装最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本： 1$ sudo yum install docker-ce docker-ce-cli containerd.io 如果提示您接受 GPG 密钥，请选是。 有多个 Docker 仓库吗？ 如果启用了多个 Docker 仓库，则在未在 yum install 或 yum update 命令中指定版本的情况下，进行的安装或更新将始终安装最高版本，这可能不适合您的稳定性需求。 Docker 安装完默认未启动。并且已经创建好 docker 用户组，但该用户组下没有用户。 要安装特定版本的 Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装： 1、列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。 $ yum list docker-ce –showduplicates | sort -r 3:18.09.1-3.el7 docker-ce-stable123docker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable 2、通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1。 1$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io 启动 Docker。 1$ sudo systemctl start docker 通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community 。 1$ sudo docker run hello-world 以上安装过程参考自： https://www.runoob.com/docker/centos-docker-install.html 开始构建应用自定义镜像根据 Dockerfile 文件进行自定义镜像的构建 在Dockerfile 文件所在的目录下执行如下命令进行自定义镜像的构建： 1sudo docker build -f Dockerfile -t 你的自定义镜像名称 . 推送到企业私有的镜像harbor之前进行登录1234docker login 企业私有的harbor地址输入用户名输入密码完成登录 将构建完成的自定义镜像推送到企业私有的harbor1sudo docker push 你的自定义镜像名称 总结 通过 1.编写自定义构建镜像的Dockerfile 2.安装Docker环境 3.构建自定义镜像 4.上传自定义镜像到harbor 以上4个步骤，我们便完成了应用自定义镜像的构建，后续我们自己的应用中直接使用自定义镜像即可，这样做的好处就是基于基础的镜像，我们可以随意组合，构建出满足自己应用的镜像，更灵活、镜像分层管理、可扩展。","tags":[{"name":"docker,镜像,harbor","slug":"docker-镜像-harbor","permalink":"http://baiwenhui.com/tags/docker-镜像-harbor/"}]},{"title":"什么？OSS存储你还在用FastDFS？MinIO了解一下！！！","date":"2020-05-05T07:13:09.000Z","path":"2020/05/05/什么？OSS存储你还在用FastDFS？MinIO了解一下！！！/","text":"什么是MinIO ？根据官方定义： MinIO 是在 Apache License v2.0 下发布的对象存储服务器。 它与 Amazon S3 云存储服务兼容。 它最适合存储非结构化数据，如照片，视频，日志文件，备份和容器/ VM 映像。 对象的大小可以从几 KB 到最大 5TB。 MinIO 服务器足够轻，可以与应用程序堆栈捆绑在一起，类似于 NodeJS，Redis 和 MySQL。 一种高性能的分布式对象存储服务器，用于大型数据基础设施。它是机器学习和其他大数据工作负载下 Hadoop HDFS 的理想 s3 兼容替代品。 为什么需要MinIO？ Minio 有良好的存储机制 Minio 有很好纠删码的算法与擦除编码算法 拥有RS code 编码数据恢复原理 公司做强做大时，数据的拥有重要性，对数据治理与大数据分析做准备。 搭建自己的一套文件系统服务,对文件数据进行安全保护。 拥有自己的平台，不限于其他方限制。 MinIO 和其他OSS存储解决方案各有什么优缺点？ 这里主要针对Ceph、Minio、FastDFS 热门的存储解决方案进行比较。 Ceph 优点 成熟 红帽继子，ceph创始人已经加入红帽 国内有所谓的ceph中国社区，私人机构，不活跃，文档有滞后，而且没有更新的迹象。 从git上提交者来看，中国有几家公司的程序员在提交代码，星辰天合，easystack, 腾讯、阿里基于ceph在做云存储，但是在开源社区中不活跃，阿里一位叫liupan的有参与 功能强大 支持数千节点 支持动态增加节点，自动平衡数据分布。（TODO，需要多长时间，add node时是否可以不间断运行） 可配置性强，可针对不同场景进行调优 缺点 学习成本高，安装运维复杂。 Minio 优点 学习成本低，安装运维简单，开箱即用 目前minio论坛推广给力，有问必答 有java客户端、js客户端 数据保护：分布式Minio采用 纠删码来防范多个节点宕机和位衰减bit rot。分布式Minio至少需要4个硬盘，使用分布式Minio自动引入了纠删码功能。 一致性：Minio在分布式和单机模式下，所有读写操作都严格遵守read-after-write一致性模型。 缺点 社区不够成熟，业界参考资料较少 不支持动态增加节点，minio创始人的设计理念就是动态增加节点太复杂，后续会采用其它方案来支持扩容。FastDFSfastdfs是阿里余庆做的一个个人项目，在一些互联网创业公司中有应用，没有官网，不活跃，6个contributors。 如何安装使用MinIO？基于 Docker 容器使用 稳定版 12docker pull minio/miniodocker run -p 9000:9000 minio/minio server /data 尝鲜版 12docker pull minio/minio:edgedocker run -p 9000:9000 minio/minio:edge server /data 基于 Mac Homebrew 使用12brew install minio/stable/miniominio server /data 下载二进制文件安装使用 操作系统 CPU架构 地址 Apple macOS 64-bit Intel https://dl.min.io/server/minio/release/darwin-amd64/minio 12chmod 755 minio./minio server /data GNU/Linux下载二进制文件 操作系统 CPU架构 地址 GNU/Linux 64-bit Intel https://dl.min.io/server/minio/release/linux-amd64/minio 12chmod +x minio./minio server /data 微软Windows系统下载二进制文件 操作系统 CPU架构 地址 微软Windows系统 64位 https://dl.min.io/server/minio/release/windows-amd64/minio.exe 1minio.exe server D:\\Photos FreeBSDPort使用 pkg进行安装。 1234pkg install miniosysrc minio_enable=yessysrc minio_disks=/home/user/Photosservice minio start 使用源码安装采用源码安装仅供开发人员和高级用户使用,如果你还没有Golang环境， 请参考 How to install Golang. 1go get -u github.com/minio/minio 使用MinIO浏览器进行验证安装后使用浏览器访问http://127.0.0.1:9000，如果可以访问，则表示minio已经安装成功。 使用MinIO客户端 mc进行验证mc 提供了一些UNIX常用命令的替代品，像ls, cat, cp, mirror, diff这些。 它支持文件系统和亚马逊S3云存储服务。 更多信息请参考 mc快速入门 - https://docs.min.io/docs/minio-client-quickstart-guide 。 已经存在的数据当在单块磁盘上部署MinIO server,MinIO server允许客户端访问数据目录下已经存在的数据。比如，如果MinIO使用minio server /mnt/data启动，那么所有已经在/mnt/data目录下的数据都可以被客户端访问到。 上述描述对所有网关后端同样有效。 了解更多 MinIO纠删码入门 mc快速入门 使用 aws-cli 使用 s3cmd 使用 minio-go SDK MinIO文档","tags":[{"name":"OSS，Java,云存储","slug":"OSS，Java-云存储","permalink":"http://baiwenhui.com/tags/OSS，Java-云存储/"}]},{"title":"Java14带来了许多新功能","date":"2020-03-04T14:17:47.000Z","path":"2020/03/04/Java14带来了许多新功能/","text":"Java 14包含比前两个发行版更多的新功能-其中大多数旨在简化编码。 劳尔·加布里埃尔·乌尔玛（Raoul-Gabriel Urma） 2020年2月27日 下载本文的PDF https://app.compendium.com/api/post_attachments/07a7a6fa-9588-4206-aa38-cf507df7a1ed/view Java 14计划于3月17日发布。版本14包含的JEP（Java增强建议）比Java 12和13的总和还多。那么，对于每天编写和维护代码的Java开发人员来说，最重要的是什么呢？ https://openjdk.java.net/projects/jdk/14/ 在本文中，我研究了以下主要方面： 改进的 switch 表达式，该表达式最初在Java 12和Java 13中作为预览出现，现在已完全成为Java 14的一部分 模式匹配instanceof（一种语言功能） 有用NullPointerException的（JVM功能） 如果您阅读本文并尝试在代码库中使用其中的某些功能，建议您通过向Java团队提供反馈来分享您的经验。这样，您就有机会为Java的发展做出贡献。 switch表达式在Java 14中，switch表达式变为永久性的。如果您需要回顾一下什么是switch表达式，那么在前 两篇文章中已广泛讨论了它们。 https://blogs.oracle.com/javamagazine/new-switch-expressions-in-java-12 https://blogs.oracle.com/javamagazine/inside-java-13s-switch-expressions-and-reimplemented-socket-api 在早期版本中，switch 表达式是“预览”功能。提醒一下，将指定为“预览”版本以收集反馈，并且根据反馈可能会更改甚至删除这些功能。但预计大多数最终将在Java中永久化。 新的switch表达式的优点包括由于没有中断行为，穷举以及由于表达式和复合形式而易于编写，从而减小了错误的范围。作为一个示例，switch表达式现在可以利用箭头语法，例如在以下示例中： 12345678910var log = switch (event) &#123; case PLAY -&gt; &quot;User has triggered the play button&quot;; case STOP, PAUSE -&gt; &quot;User needs a break&quot;; default -&gt; &#123; String message = event.toString(); LocalDateTime now = LocalDateTime.now(); yield &quot;Unknown event &quot; + message + &quot; logged on &quot; + now; &#125;&#125;; 文本块Java 13引入了文本块作为预览功能。文本块使使用多行字符串文字更加容易。此功能将通过Java 14进行第二轮预览，并进行了一些调整。作为编写带有许多字符串连接和转义序列的代码以提供适当的多行文本格式非常普遍。下面的代码显示了HTML格式的示例： 12345String html = &quot;&lt;HTML&gt;&quot; +&quot;\\n\\t&quot; + &quot;&lt;BODY&gt;&quot; +&quot;\\n\\t\\t&quot; + &quot;&lt;H1&gt;\\&quot;Java 14 is here!\\&quot;&lt;/H1&gt;&quot; +&quot;\\n\\t&quot; + &quot;&lt;/BODY&gt;&quot; +&quot;\\n&quot; + &quot;&lt;/HTML&gt;&quot;; 使用文本块，您可以简化此过程并使用界定文本块开头和结尾的三个引号来编写更优雅的代码： 123456String html = &quot;&quot;&quot;&lt;HTML&gt; &lt;BODY&gt; &lt;H1&gt;&quot;Java 14 is here!&quot;&lt;/H1&gt; &lt;/BODY&gt;&lt;/HTML&gt;&quot;&quot;&quot;; 与普通字符串文字相比，文本块还提供了更高的表达能力。您可以在较早的文章中了解有关此内容的更多信息。 https://blogs.oracle.com/javamagazine/text-blocks-come-to-java Java 14中添加了两个新的转义序列。首先，您可以使用新的\\s转义序列表示单个空格。其次，您可以使用反斜线\\来禁止在行尾插入新行字符。当您想分隔很长的行以简化文本块内的可读性时，这很有用。 例如，当前处理多行字符串的方法是 1234String literal = &quot;Lorem ipsum dolor sit amet, consectetur adipiscing &quot; + &quot;elit, sed do eiusmod tempor incididunt ut labore &quot; + &quot;et dolore magna aliqua.&quot;; 使用\\文本块中的转义序列，可以将其表示为： 12345String text = &quot;&quot;&quot; Lorem ipsum dolor sit amet, consectetur adipiscing \\ elit, sed do eiusmod tempor incididunt ut labore \\ et dolore magna aliqua.\\ &quot;&quot;&quot;; instanceof的模式匹配Java 14引入了预览功能，该功能有助于消除对在进行条件instanceof检查之前进行显式强制转换的需求。例如，考虑以下代码： 123456if (obj instanceof Group) &#123; Group group = (Group) obj; // use group specific methods var entries = group.getEntries();&#125; 可以使用预览功能将其重构为： 123if (obj instanceof Group group) &#123; var entries = group.getEntries();&#125; 因为条件检查断言obj是type Group，所以为什么要在第一个代码段中用条件块再次说该obj类型Group？这种需求可能会增加错误的范围。 较短的语法将删除典型Java程序中的许多强制转换。（A 研究论文从2011年提出了一个相关的语言特性报告说，所有铸件约24％遵循instanceof的条件语句。） http://www.cs.williams.edu/FTfJP2011/6-Winther.pdf JEP 305涵盖了此更改，并从Joshua Bloch 的Effective Java书中指出了一个示例，该示例通过以下相等方法进行说明： https://openjdk.java.net/jeps/305 1234@Override public boolean equals(Object o) &#123; return (o instanceof CaseInsensitiveString) &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s); &#125; 通过删除冗余的显式强制转换为，可以将前面的代码简化为以下形式CaseInsensitiveString： 1234@Override public boolean equals(Object o) &#123; return (o instanceof CaseInsensitiveString cis) &amp;&amp; cis.s.equalsIgnoreCase(s); &#125; 这是一个有趣的预览功能，因为它为更广泛的模式匹配打开了大门。模式匹配的思想是为语言功能提供方便的语法，以便根据某些条件提取对象的成分。instanceof运算符就是这种情况，因为条件是类型检查，并且提取操作正在调用适当的方法或访问特定字段。 换句话说，此预览功能仅仅是个开始，您可以期待一种语言功能，它可以帮助进一步减少冗长性，从而减少错误的可能性。 记录还有另一种预览语言功能：records。像到目前为止提出的其他想法一样，此功能遵循减少Java冗长并帮助开发人员编写更简洁的代码的趋势。记录集中在某些域类上，这些类仅用于将数据存储在字段中，并且不声明任何自定义行为。 为了直接解决该问题，请使用一个简单的域类，该类BankTransaction通过三个字段对交易进行建模：日期，金额和描述。声明类时，您需要担心多个组件： 构造函数 equals方法 toString() hashCode() 和 equals() 此类组件的代码通常由IDE自动生成，并占用大量空间。这是BankTransaction该类的完整生成的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BankTransaction &#123; private final LocalDate date; private final double amount; private final String description; public BankTransaction(final LocalDate date, final double amount, final String description) &#123; this.date = date; this.amount = amount; this.description = description; &#125; public LocalDate date() &#123; return date; &#125; public double amount() &#123; return amount; &#125; public String description() &#123; return description; &#125; @Override public String toString() &#123; return &quot;BankTransaction&#123;&quot; + &quot;date=&quot; + date + &quot;, amount=&quot; + amount + &quot;, description=&apos;&quot; + description + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; BankTransaction that = (BankTransaction) o; return Double.compare(that.amount, amount) == 0 &amp;&amp; date.equals(that.date) &amp;&amp; description.equals(that.description); &#125; @Override public int hashCode() &#123; return Objects.hash(date, amount, description); &#125;&#125; Java的14提供了一种方法来去除冗长，使意图明确指出，所有你想要的是，只有拥有的实现数据聚合在一起的一类equals，hashCode和toString方法。您可以BankTransaction按以下方式重构： 123public record BankTransaction(Date date, double amount, String description) &#123;&#125; 有了记录，你“自动”得到的实现equals，hashCode以及toString除了构造函数和getter。 要尝试该示例，请记住您需要使用预览标志来编译文件： 1javac --enable-preview --release 14 BankTransaction.java 记录的字段是隐式的final。这意味着您无法重新分配它们。但是请注意，这并不意味着整个记录都是不变的。存储在字段中的对象本身可以是可变的。 如果您对有关记录的更详细的文章感兴趣，请参阅Java杂志上 Ben Evans的最新文章。 https://blogs.oracle.com/javamagazine/records-come-to-java 敬请关注。从教育的角度来看，唱片还为下一代Java开发人员提出了有趣的问题。例如，如果您指导初级开发人员，那么什么时候应该在课程中引入记录：在引入OOP和类之前还是之后？ 有用的NullPointerExceptions有人说throw NullPointerException应该是Java中新的“ Hello world”，因为您无法逃避它们。除了笑话，它们还导致挫败感，因为当代码在生产环境中运行时，它们经常出现在应用程序日志中，这可能使调试变得困难，因为原始代码不容易获得。例如，考虑以下代码： 1var name = user.getLocation().getCity().getName(); 在Java 14之前，您可能会收到以下错误： 12Exception in thread &quot;main&quot; java.lang.NullPointerException at NullPointerExample.main(NullPointerExample.java:5) 不幸的是，如果在第5行，则有一个具有多个方法调用的赋值- getLocation()和- getCity()两者都可能返回null。实际上，变量user也可以为null。因此，目前尚不清楚是什么原因引起的NullPointerException。 现在，使用Java 14，有一个新的JVM功能，通过它您可以收到更多信息的诊断信息： 12Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;Location.getCity()&quot; because the return value of &quot;User.getLocation()&quot; is null at NullPointerExample.main(NullPointerExample.java:5) 该消息现在具有两个明确的组成部分： 结果： Location.getCity()无法调用。 原因：的返回值为User.getLocation()null。 仅当您使用以下标志运行Java时，增强型诊断才有效： 1-XX:+ShowCodeDetailsInExceptionMessages 这是一个例子： 1java -XX:+ShowCodeDetailsInExceptionMessages NullPointerExample 在Java的未来版本中，这项功能可能会被默认启用，据报道在这里。 https://bugs.openjdk.java.net/browse/JDK-8233014 此增强功能不仅可用于方法调用，而且还可在可能导致的其他地方使用NullPointerException，包括字段访问，数组访问和赋值。 结论在Java 14中，有新的预览语言功能和更新可帮助开发人员进行日常工作。例如，Java 14引入了instanceof模式匹配，这是减少显式转换的一种方法。而且，Java 14引入了记录，这是一种新的结构，用于简洁地声明仅用于聚合数据的类。此外，NullPointerException消息已通过更好的诊断得到了增强，并且开关表达式现在已成为Java 14的一部分。文本块是一种可帮助您处理多行字符串值的功能，在引入了两个新的转义序列后，将进行另一轮预览。Java操作的一部分技术人员可能会感兴趣的另一项更改是JDK Flight Recorder中的事件流。该选项在本埃文斯的这篇文章。 https://openjdk.java.net/jeps/349 https://blogs.oracle.com/javamagazine/java-flight-recorder-and-jfr-event-streaming-in-java-14 如您所见，Java 14带来了很多创新。您绝对应该使用一下，并将有关预览功能的反馈发送给Java团队。","tags":[{"name":"java,java14,java语言","slug":"java-java14-java语言","permalink":"http://baiwenhui.com/tags/java-java14-java语言/"}]},{"title":"那些年非常火的MyCAT是什么？","date":"2020-02-29T15:28:09.000Z","path":"2020/02/29/那些年非常火的MyCAT是什么？/","text":"什么是 MyCAT ？根据 MyCAT 官网 - http://mycat.io/ 的描述可以知道， MyCAT 是如下的一个东东： 一个彻底开源的，面向企业应用开发的大数据库集 支持事务、ACID、可以替代MySQL的加强版数据库 一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群 一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server 结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品 一个新颖的数据库中间件产品 总结一下就是： MyCAT 是一款数据库中间件，类似于Tomcat 容器或者相关的 Web 中间件。它主要用于解决数据库相关的问题。 MyCAT 能干什么？为什么要使用它？使用它可以解决什么问题？ 用于支持海量数据存储，对海量数据进行分库分表 支持分库分表场景下的分布式事务 对多个数据源进行统一整合 高并发应用场景下，降低请求对单个数据库节点带来的灾难性压力 可以通过数据库中间间层面实现数据库读写分离，使其Java程序与数据库访问解耦 具体更多的特性可以参考 http://mycat.io/ 对MyCAT 特性的介绍。总结下来的一般常用的用途有3个，分别如下： 数据读写分离 数据分片 多数据源整合 MyCAT 是唯一的数据库分库分表的解决方案吗？与其它的数据库中间件有什么区别？我们来看如下图，图片来源于网络： 具体介绍如下： Cobar 属于阿里 B2B 事业群，始于 2008 年，在阿里服役 3 年多，接管 3000+ 个 MySQL 数据库的 schema, 集 群日处理在线 SQL 请求 50 亿次以上。由于 Cobar 发 起人的离职， Cobar 停止维护。 My cat 是开源社区在阿里 cobar 基础上进行二次开发，解决了 cobar 存在的问题，并且加入了许多新 的功能在其中。青出于蓝而胜于蓝。 OneProxy 基于 MySQL 官方的 proxy 思想利用 c 进行开发的， OneProxy 是一款商业收费的中间件。舍 弃了一些功能，专注在性能和稳定性上。 kingshard 由小团队用 go 语言开发，还需要发展，需要不断完善 。 Vite ss 是 Youtube 生产在使用 架构很复杂。不支持 MySQL 原生协议，使用需要大量改造成本 。 Atlas 是 3 60 团队基于 mysql proxy 改写 ，功能还需完善 ，高并发下不稳定 。 MaxScale 是 mariadb MySQL 原作者维护的一个版本 研发的中间件 MySQLRout e 是 MySQL 官方 Oracle 公司发布的中间件 除了这些之外，我们去github 搜罗了一下，还有如下的一些数据库中间件： Oceanus - 58同城数据库中间件，github star 数 500+； SOHU-DBProxy - 是由 搜狐 数据库团队开发维护的一个基于MySQL协议的数据中间层项目。它在MySQL官方推出的MySQL-Proxy 0.8.3版本的基础上， 修改了大量bug，添加了很多功能特性。现在已经在sohu的多个业务线上使用， github star 数 700+； Cetus是由C语言开发的关系型数据库MySQL的中间件，主要提供了一个全面的数据库访问代理功能。Cetus连接方式与MySQL基本兼容，应用程序几乎不用修改即可通过Cetus访问数据库，实现了数据库层的水平扩展和高可用。 ， github star 数 1000+； Zebra是一个基于JDBC API协议上开发出的高可用、高性能的数据库访问层解决方案，是美团点评内部使用的数据库访问层中间件。github star 数 1500+; MyCAT作为分库分表中间件的原理是什么？ Mycat收到一条SQL语句时， 首先解析SQL语句涉及的表， 接着查看此表的定义， 如果该表存在分片规则， 则获取SQL语句里分片字段的值， 并匹配分片函数， 得到该SQL语旬对应的分片列表， 然后将SQL语句发送到相应的分片去执行， 最后处理所有分片返回的数据并返回给客户端。 以 select* from Orders where prov=? 语句为例， 查找prov=wuhan, 按照分片函数， wuhan值存放在dnl上， 于是SQL语句被发送到Mysql l , 把DBI上的查询结果返回给用户。 这里使用过阿里巴巴数据源 Druid 的同学不知道有没有发现，在Druid 中有一个叫做 SQLParser 的东东，这个玩意其实就是可以用来对原始的SQL语句，根据SQL语法树，对SQL进行加强改造的一个解析器，如果你们项目中有做过表数据的行权限或者列权限，则用这个Druid 的SQLParser 对所有的SQL 进行拦截改写是一个不错的方案，我之前在做数据权限的时候，参考相关实现时，也发现了MyCAT 中对于SQL的解析和改写也使用的这个，具体可以参考：https://github.com/MyCATApache/Mycat-Server/blob/f929f96a16852869bc9dc63f4c0f192ee02818e0/src/main/java/io/mycat/statistic/stat/UserSqlHighStat.java MyCAT 入门 对于一款开箱即用的数据库分库分表中间件来说，MyCAT的入门相对简单，只需要按照官方的入门指导一步步往下走即可。 安装安装之前我们首先准备环境，这里我们以企业中生产使用最多的Centos 7 为示例，进行下面的实操，本次CentOS 7 的内核版本如下：1Linux VM_0_14_centos 3.10.0-862.el7.x86_64 由于 MyCAT 源码是通过 Java 语言进行开发的，因此在我们使用之前，需要先检查自己的CentOS 7 主机具备不具备Java 环境，使用java -version 进行验证，如果没有安装JDK，则首先需要安装JDK并且配置Java环境变量才阔以，Centos 7 安装Java8 比较容易，只需要如下一行命令即可：1yum -y install java-1.8.0-openjdk JDK8 安装完毕之后，进行如下验证，没有错误即可：1java -version 123openjdk version &quot;1.8.0_242&quot;OpenJDK Runtime Environment (build 1.8.0_242-b08)OpenJDK 64-Bit Server VM (build 25.242-b08, mixed mode) 接下来我们根据官方的入门指导，下载mycat server 包，下载地址为：http://dl.mycat.io/ , 这里我们实验时使用MyCAT 1.6.7.3 release 版本即可，下载 1.6.7.3 release 安装包到自己主机的 /opt 目录下 , 操作命令如下:1cd /opt/ &amp;&amp; wget /usr/local/ http://dl.mycat.io/1.6.7.3/20190927161129/Mycat-server-1.6.7.3-release-20190927161129-linux.tar.gz 下载完成之后，我们对mycat 安装包进行解压即可，命令如下：1tar -zxvf Mycat-server-1.6.7.3-release-20190927161129-linux.tar.gz 解压完成之后，我们看到 /opt 目录下有了一个 mycat 目录，我们进入到该目录下，发现它的子目录主要有如下：12345678.├── bin├── catlet├── conf├── lib├── logs├── tmlogs└── version.txt 这里我们进入到conf 目录下，只关注如下的几个配置文件即可,其它的配置文件先不用关心：12server.xml 定义逻辑库，表、分片节点等内容schema.xml 定义用户以及系统相关变量，如端口等 修改相关配置为了对用户进行区分，此时，我们先修改 server.xml 中的 root 用户为 mycat，当使用 mycat 用户连接时，就代表我们直连的是 mycat，其它的配置不动，具体修改如下： 12345678910111213141516171819... &lt;!-- 修改之前的 root 用户为 mycat --&gt; &lt;user name=&quot;mycat&quot; defaultAccount=&quot;true&quot;&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt; &lt;!-- 表级 DML 权限设置 --&gt; &lt;!-- &lt;privileges check=&quot;false&quot;&gt; &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt; &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt; &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt; &lt;/schema&gt; &lt;/privileges&gt; --&gt; &lt;/user&gt;...&lt;/mycat:server&gt; 接下来我们修改 schema.xml 删除 标签间的 表信息 dataNode 标签只留一个 dataHost 标签只留一个 writeHost","tags":[{"name":"java,中间件,MyCAT","slug":"java-中间件-MyCAT","permalink":"http://baiwenhui.com/tags/java-中间件-MyCAT/"}]},{"title":"ES数十亿数据量级的场景下如何优化查询性能","date":"2020-02-03T01:57:26.000Z","path":"2020/02/03/ES数十亿数据量级的场景下如何优化查询性能/","text":"ES 客户端读取数据的流程客户端 -&gt; shard -&gt; filesystem cache -&gt; 磁盘文件 海量数据检索查询性能优化思路如果内存足够大， filesystem cache 会缓存，如果查询走filesystem cache 则速度耗时在毫秒级别，如果查询请求走磁盘文件，则最少查询耗时都在秒级别。 如果整个磁盘上索引数据文件在3台机器上，一共占用了1T的磁盘容量，ES数据量是1T，每台机器的数据量是300G。ES性能最佳情况，你的机器内存至少可以容纳总数据量的一半。 生产环境试验，最好用ES存储少量的数据，用来搜索的那些索引，内存留给filesystem cache ， 100G。数据量控制在100G以内，相当于查询的数据几乎全部走内存来搜索，性能非常高，几乎搜索结果在1秒以内就可以出结果。 另外还有注意的一点，就是在ES中真正存储的记录字段都应该是你需要查询的字段，不应该把整条记录中的所有字段都放在ES中，如果全部字段都放到ES中，则会导致你机器的filesystem chche 占据空间很大，很多记录其实查询都要走硬盘文件，这样会导致查询性能会很低。 数据预热后台系统自动搜索一下热数据，提前让数据加载到filesystem cache 中，当客户端查询时，直接从 filesystem cache中找到，性能非常高。 冷热分离类似于MySQL的冷热分离，将大量访问不频繁的数据放到单独的一个索引。将查询频繁的放到一个索引，提高查询的性能。 模型设计写入索引的时候，就将关联的数据直接写入进去，不要在搜索的时候进行join，因为ES中的复杂查询都很耗费性能。 分页查询分布式的，查100页的10条数据，必须从每个shard，都查询一批数据过来，然后拿过来在内存里面分页，页翻得越深，基本查询性能很差。优化策略：1.不允许深度分页 2.类似于下拉分页的话，可以使用 scroll api 进行查询。它的分页原理，会一次性生成快照，然后通过游标一次一次往下翻，无论翻多少页，性能就是毫秒级的，scroll 智能一页一页往后翻，天然适合微博，往下拉的时候。","tags":[{"name":"java,ES,大数据","slug":"java-ES-大数据","permalink":"http://baiwenhui.com/tags/java-ES-大数据/"}]},{"title":"Oracle JDK 和 OpenJDK 之间的区别","date":"2019-02-13T01:38:59.000Z","path":"2019/02/13/Oracle-JDK-和-OpenJDK-之间的区别/","text":"1.简介在本文中，我们将探讨Oracle Java Development Kit和OpenJDK之间的差异。我们先快速浏览一下，然后进行比较。之后，我们将看到其他JDK实现的列表。 2. Oracle JDK和Java SE历史JDK（Java Development Kit）是Java平台编程中使用的软件开发环境。它包含一个完整的Java运行时环境，即所谓的私有运行时。该名称来自于它包含的工具多于独立的JRE以及开发Java应用程序所需的其他组件。 Oracle强烈建议使用术语JDK来引用Java SE（标准版）开发工具包（还有Enterprise Edition和Micro Edition平台）。 我们来看看Java SE的历史： JDK Beta - 1995 JDK 1.0 - 1996年1月 JDK 1.1 - 1997年2月 J2SE 1.2 - 1998年12月 J2SE 1.3 - 2000年5月 J2SE 1.4 - 2002年2月 J2SE 5.0 - 2004年9月 Java SE 6 - 2006年12月 Java SE 7 - 2011年7月 Java SE 8（LTS） - 2014年3月 Java SE 9 - 2017年9月 Java SE 10（18。3） - 2018年3月 Java SE 11（18.9 LTS） - 2018年9月 Java SE 12（19。3） - 2019年3月 注意：不再支持斜体版本。 我们可以看到Java SE的主要版本大约每两年发布一次，直到Java SE 7.从Java SE 6开始花了五年时间，之后又花了三年时间升级到Java SE 8。 自Java SE 10以来，我们可以期待每六个月发布一次新版本。但是，并非所有版本都是长期支持（LTS）版本。由于Oracle的发布计划，LTS产品发布仅每三年发布一次。 Java SE 11是最新的LTS版本，Java SE 8将在2020年12月之前获得免费的公共更新，用于非商业用途。 在2010年Oracle收购Sun Microsystems之后，这个开发工具包得到了它的当前名称。在此之前，它的名字是SUN JDK，它是Java编程语言的官方实现。 3. OpenJDKOpenJDK是Java SE 平台版本的免费开源实现。它最初于2007年发布，是Sun Microsystems于2006年开始开发的结果。 当然，我们应该强调 OpenJDK是自SE 7版以来Java标准版的官方参考实现。 最初，它仅基于JDK 7.但是，从Java 10开始，Java SE平台的开源参考实现是JDK项目http://openjdk.java.net/projects/jdk/的责任。而且，就像Oracle一样，JDK项目也将每六个月发布一次新功能。 我们应该注意到，在这个长期运行的项目之前，JDK Release Projects发布了一个功能，然后停止了。 现在让我们看看OpenJDK版本： OpenJDK 6项目 - 基于JDK 7，但经过修改后提供了Java 6的开源版本 OpenJDK 7项目 - 2011年7月28日 OpenJDK 7u项目 - 该项目开发Java Development Kit 7的更新 OpenJDK 8项目 - 2014年3月18日 OpenJDK 8u项目 - 该项目开发Java Development Kit 8的更新 OpenJDK 9项目 - 2017年9月21日 JDK10项目于2018年3月10日至20日发布 JDK11项目于2018年9月11日至25日发布 JDK12项目发布 - 稳定阶段 4. Oracle JDK与OpenJDK在本节中，我们将重点介绍Oracle JDK和OpenJDK之间的主要区别。 4.1. 发布时间表正如我们所提到的，Oracle将每三年发布一次，而OpenJDK将每六个月发布一次。 Oracle为其版本提供长期支持。另一方面，OpenJDK仅支持对发布的更改，直到下一个版本发布。 4.2. 许可证Oracle JDK根据Oracle二进制代码许可协议获得许可，而OpenJDK具有GNU通用公共许可证（GNU GPL）版本2，使用了一个修正版本。 使用Oracle平台时会产生一些许可影响。如Oracle 宣布的那样，在没有商业许可的情况下，在2019年1月之后发布的Oracle Java SE 8的公开更新将无法用于商业，商业或生产用途。但是，OpenJDK是完全开源的，可以自由使用。 4.3. 性能有两者之间没有真正的技术差别，因为针对Oracle JDK构建过程是基于OpenJDK的的。 在性能方面，Oracle在响应能力和JVM性能方面要好得多。由于其对企业客户的重要性，它更加关注稳定性。 相比之下，OpenJDK将更频繁地发布版本。结果，我们可能遇到不稳定的问题。根据社区反馈，我们知道一些OpenJDK用户遇到了性能问题。 4.4. 功能如果我们比较功能和选项，我们将看到 Oracle产品具有Flight Recorder，Java Mission Control和Application Class-Data Sharing 功能，而OpenJDK具有Font Renderer功能。 此外，Oracle有更多的垃圾收集选项和更好的渲染器，我们可以在另一个比较中看到。 4.5. 发展与人气Oracle JDK由Oracle Corporation完全开发，而OpenJDK由Oracle，OpenJDK和Java Community开发。然而，红帽，Azul Systems，IBM，Apple Inc.，SAP AG等顶级公司也积极参与其开发。 正如我们从前一小节的链接中看到的那样，当涉及到在其工具中使用Java开发工具包的顶级公司（例如Android Studio或IntelliJ IDEA）的流行时，Oracle JDK是更**受欢迎的**。 另一方面，主要的Linux发行版（Fedora，Ubuntu，Red Hat Enterprise Linux）提供OpenJDK作为默认的Java SE实现。 5.自Java 11以来的变化正如我们在Oracle博客文章中看到的那样 ，从Java 11开始有一些重要的变化。 首先，Oracle将使用Oracle JDK作为Oracle产品的一部分，将开源**GNU通用公共许可证v2与Classpath Exception（GPLv2 + CPE）**和商业许可证结合使用，或者更改其历史“ BCL ”许可证， 或者服务，或不欢迎开源软件。 每个许可证都有不同的版本，但这些版本在功能上只与一些装饰和包装差异相同。 此外，OpenJDK现在提供传统的“商业功能”，如Flight Recorder，Java Mission Control和Application Class-Data Sharing，以及Z Garbage Collector。因此，Oracle JDK和OpenJDK构建从Java 11开始基本相同。 让我们看看主要的区别： 使用-XX：+ UnlockCommercialFeatures选项时，Oracle的Java 11工具包会发出警告，而在OpenJDK版本中，此选项会导致错误 Oracle JDK提供了一种配置，可将使用日志数据提供给“高级管理控制台”工具 Oracle一直要求第三方加密提供程序由已知证书签名，而OpenJDK中的加密框架具有开放加密接口，这意味着可以使用哪些提供程序没有限制 Oracle JDK 11将继续包括安装程序，品牌和JRE打包，而OpenJDK构建目前可用作zip和tar.gz文件 该javac的-释放命令行为有所不同了Java 9和Java 10个目标由于一些额外的模块在Oracle的版本存在 java -version和java -fullversion命令的输出将Oracle的构建与OpenJDK构建区分开来 6.其他JDK实现现在让我们快速浏览一下其他活动的Java Development Kit实现。 6.1. 自由开源按字母顺序列出的以下实现是开源的，可以免费使用： Amazon Corretto Azul Zulu Bck2Brwsr CACAO Codename One DoppioJVM Eclipse OpenJ9 GraalVM CE HaikuVM HotSpot Jamiga JamVM Jelatine JVM Jikes RVM (Jikes Research Virtual Machine) JVM.go leJOS Maxine Multi-OS Engine RopeVM uJVM 6.2. 专有实现还有受版权保护的实施： Azul Zing JVM CEE-J Excelsior JET GraalVM EE Imsys AB JamaicaVM（aicas） JBlend（Aplix） MicroJvm（IS2T - 工业智能软件技术） OJVM PTC Perc SAP JVM Waratek CloudVM for Java 与上面列出的有效实现一起，我们可以看到非有效实现的列表 以及每个实现的简短描述。 7.结论在本文中，我们专注于当今最流行的两个Java开发工具包。 我们首先描述了它们中的每一个，然后强调了它们之间最显着的差异。然后，我们特别关注自Java 11以来的变化和差异。最后，我们列出了今天可用的其他有效实现。","tags":[{"name":"JDK,JAVA,OpenJDK,OracleJDK","slug":"JDK-JAVA-OpenJDK-OracleJDK","permalink":"http://baiwenhui.com/tags/JDK-JAVA-OpenJDK-OracleJDK/"}]},{"title":"CAP 理论","date":"2018-07-09T15:40:00.000Z","path":"2018/07/09/CAP-理论/","text":"2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。 一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。 Consistency 一致性 一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。分布式的一致性 对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。 从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。 Availability 可用性可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。也就是，该系统使用的任何算法必须最终终止。当同时要求分区容忍性时，这是一个很强的定义：即使是严重的网络错误，每个请求必须终止。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。 Partition Tolerance分区容错性分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。 CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。 CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。 AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。 对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。 整理自：http://www.hollischuang.com/archives/666","tags":[{"name":"分布式，CAP","slug":"分布式，CAP","permalink":"http://baiwenhui.com/tags/分布式，CAP/"}]},{"title":"《深入理解Java虚拟机》- Java 内存区域读书笔记","date":"2018-04-22T09:19:00.000Z","path":"2018/04/22/《深入理解Java虚拟机》-Java-内存区域读书笔记/","text":"概述 对于 Java 程序员来说，在我们平时的编码过程中，并不会手动的去分配内存和回收内存，因为对于内存这块的处理都是依赖于 JVM 的，这样会导致一个问题：就是如果我们对 JVM 的内存管理机制不是特别熟悉的前提下，如果程序在内存这块出现了莫名的问题，此时处理这些问题就是一个灾难，因此，对于 Java 内存区域这块需要我们有一个清晰的认知，这样才可以在出现问题是根据 JVM 内存管理这块有好的解决方案。在我们学习 运行时数据区域之前，我们先概览一下 JVM 的整体架构，这样对于我们下面内容的理解是有很大的帮助的，先将 JVM 整体的架构图展示如下：简版的图如下：详细点儿的图如下： 运行时数据区域 一般情况下，运行时数据区域主要包含：程序计数器 、Java 虚拟机栈、本地方法栈、Java 堆、方法区这几个大的部分。对于此结构，通过图的方式进行如下展示：由图示意可知：其中Method Area (方法区) 和 Heap(堆) 是线程共享的，VM Stack (虚拟机栈)、Native Method Area （本地方法栈)、Programmer Computer Register(程序计数器) 是线程私有的。当我们分析到这边之后，会有一个疑问？为什么 JVM 要将内存划分为线程共享和非线程共享呢？ 我们可以回顾下 Java 程序执行的流程。Java 源文件 – 字节码文件(使用 Javac 编译为 *.class) – 每个 Java 程序都需要运行在 自己的 JVM 之上，JVM 会找到程序运行的入口，JVM 通过字节码解释器加载字节码运行。程序运行后JVM 如何对内存进行划分呢？其实 JVM 在初始化的时候，会分配好方法区（Method Area） 和 堆（Heap），当 JVM 遇到一个线程的时候，便会为其分配一个程序计数器(Programmer Register)、JVM虚拟机栈（VM Stack） 和 本地方法栈(Native Method Stack)，当线程死亡的时候，虚拟机栈、本地方法栈、程序计数器所占用的内存会被释放掉。通过这里的分析，便可以了解到，JVM 将内存区域分为线程共享和非线程共享两个部分，非线程共享的区域与所属的线程的生命周期相同，而线程共享的区域与 JVM 虚拟机的生命周期相同。这样也可以说明，其实 JVM 大多数的垃圾回收是发生在线程共享的区域（实际上更多位于堆上）。 对于运行时数据区域总体的理解，可以参考下图： 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，可看做是当前线程所执行字节码行号的指示器。Java 虚拟机中多线程的执行原理是通过线程轮流切换并分配执行时间的方式来实现的，一般情况下在单核的处理器中，处理器在某一时刻只能处理一条线程中的指令。为了线程切换后能恢复到上次执行的位置，每个线程需要一个独立的计数器，每个线程之间的计数器是互不影响的。因此计程序计数器区域为“线程私有” 的内存。 如果线程执行的是一个 Java 方法，则程序计数器记录的是正在执行的虚拟机字节码指令的地址，如果执行的是 Native 方法，则计数器为Undefined。 Java 虚拟机栈 Java 虚拟机栈和程序计数器一样属于线程私有。虚拟机栈主要描述 Java 执行时的内存模型：每个方法在执行的同时会创建一个栈帧（Stack Frame） 用于存储变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 虚拟机栈中的局部变量表存放在编译期间可知的基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型）和 returnAddress 类型（指向一条字节码指令的地址）。 其中 64 位长度的 long 和 double 会占用 2 个局部变量空间，其它的只占用 1 个局部变量空间。一般局部变量所需在帧中分配多大的局部变量空间在程序编译期间完成分配，程序运行期间不会改变局部变量表的大小。 Java 虚拟机规范中指出，当线程请求的栈深度大于虚拟机所允许的深度时，会抛出 StackOverflowError 异常。 本地方法栈 本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用非常相似，它们之间的区别在于虚拟机栈为虚拟机执行 Java 方法（执行字节码）服务，而 本地方法栈为虚拟机使用的 Native 方法服务。虚拟机规范中没有对本地方法栈做强制的规定，由具体的虚拟机自己实现，Sun HotSpot 虚拟机字节将本地房发展和虚拟机栈合二为一。通虚拟机栈类似，本地房发展也会抛出 StackOverflowError 和 OutOfMemoryError 异常。 Java 堆 Java 堆是Java 虚拟机所管理内存中最大的一块。Java 堆被所有线程共享，此区域的唯一目的便是存放对象的实例。 Java 虚拟机规范规定：所有的对象实例以及数组都要在堆上进行分配，随着 JIT 编译器的发展与内存逃逸技术的成熟，栈上分配、标量替换优化技术使所有对象分配在堆上的结论不是那么“绝对”。 Java 堆是垃圾回收的主要区域，可将 Java 堆划分为：新生代和老年代；更细的划分新生代包含 Eden 空间、From Survivor、To Survivor 空间等。 Java 虚拟机规范规定，Java 堆可以处于物理机器上不连续的内存空间中。当堆空间无法分配扩展时，将会抛出 OutOfMemoryError 异常。 对于堆的加深理解可以参考此图： 方法区 方法去（Method Area）和 Java 堆类似，也属于各个线程共享的内存区域，主要用来存放被 JVM 虚拟机加载的类信息、常量、静态变量。即时编译器编译后的代码等数据。方法区又称为非堆。方法区本质上与“永久代”（Permanent Generation）不等价，主要原因是 HotSpot 虚拟机的设计团队把 GC 分代收集扩展到了方法区，换句话说就是使用永久代实现了方法区。在 JDK1.7 的 HotSpot中，由于永久代区域是一个类的静态区域，主要存储类的加载信息，常量池，方法代码等内容，默认大小只有 4 m，如果在常量池中大量的比如使用 String.intern() 方法会直接导致发生 java.lang.OutOfMemoryError: PermGen space，所以在 jdk7 的版本中，字符串常量池已经从 Perm 区移动到 Java Heap 区域了。主要是原因是：Perm 区域太小，在 Java 8 中已经取消了永久代进而代替的是元区域（Meta Space）。根据 Java 虚拟机规范规定，当方法区无法满足内存分配需求时，会产生 OutOfMemoryError 异常，也称为 OOM 。 运行时常量池 运行时常量池（Runtime Constant Pool） 属于方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项便是常量池（Runtime Constant Pool），常量池主要作用为：存放编译期间生成的各种字面量和符号引用，这些内容将在 Java 类被加载后进入方法区的运行时常量池中存放。运行时常量另外一个重要特征便是具备动态性，具体的案例便是使用 String 的 intern 方法，不要求常量只在类编译期间才能产生，在运行期间也可以将新的常量放入池中。运行时常量池属于方法区的一部分，当常量池无法进行内存分配时，也会抛出 OutOfMemoryError 异常。 直接内存 直接内存（Direct Memory） 不是虚拟机运行时数据区域的一部分，也不是 Java 虚拟机规范中定义的内存区域。这部分的内存也会被频繁使用，当内存分配空间不足时，也会抛出 OutOfMemoryError 异常。对于直接内存使用的典型案例便是，在 JDK 1.4 之后，新加入了 NIO（New Input/Output） 类，其核心原理是基于通道 （Channel） 与 缓冲区 （Buffer） 的 I/O 方式，可以通过 Native 函数库直接分配堆外内存，然后通过存储在 Java 堆中的 DirectByteBuffer 对象作为内存的引用进行操作。 这样的优点就是在一些场景中提高性能，避免了 Java 堆和 Native 来回赋值数据的开销。 本地内存的分配不会受到 JVM 堆大小的限制，但是会受到系统本身内存大小的限制，当系统本身内存空间不够用时，也会出现 OutOfMemory 异常。","tags":[{"name":"jvm","slug":"jvm","permalink":"http://baiwenhui.com/tags/jvm/"}]},{"title":"《深入理解Java虚拟机》-走近 Java 读书笔记","date":"2018-03-26T14:48:00.000Z","path":"2018/03/26/《深入理解Java虚拟机》-走近-Java-读书笔记/","text":"走进Java概述Java 的优点 结构严谨 平台无关性，一次编写到处运行 提供安全的内存管理和访问机制，避免大部分的内存泄漏和指针越界 热点代码检测和运行时编译优化，使得 Java 应用随运行时间的增加而获得更高的性能 具有一套完善的应用程序接口，丰富的第三方库 Java 技术体系 Java 程序设计语言 各种硬件平台上的 Java 虚拟机 Java API 类库 Class 文件格式 来自商业机构和开源的第三方 Java 类库 JDK组成Java 程序设计语言 + Java 虚拟机 + Java API 类库 JRE 组成Java SE API 子集 + Java 虚拟机 Java 技术体系所包含的内容 Java 体系划分的 4 个平台 Java Card Java ME Java SE Java EE Java 发展史 JDK 1.0: Java虚拟机、Applet、AWT等； JDK 1.1：JAR文件格式、JDBC、JavaBeans、RMI、内部类、反射； JDK 1.2：拆分为J2SE/J2EE/J2ME、内置JIT编译器、一系列Collections集合类； JDK 1.3：JNDI服务、使用CORBA IIOP实现RMI通信协议、Java 2D改进； JDK 1.4：正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器； JDK 1.5：自动装箱、泛型、动态注解、枚举、可变参数、遍历循环、改进了Java内存模型、提供了java.util.concurrent并发包； JDK 1.6：提供动态语言支持、提供编译API和微型HTTP服务器API、虚拟机优化（锁与同步、垃圾收集、类加载等）； JDK 1.7：G1收集器、加强对Java语言的调用支持、升级类加载架构； JDK 1.8：Lambda表达式等； Java 虚拟机发展史 展望 Java 技术的未来 模块化 混合语言 多核并行 进一步丰富的语法 64 位虚拟机","tags":[{"name":"JVM","slug":"JVM","permalink":"http://baiwenhui.com/tags/JVM/"}]},{"title":"Grails中神奇的HibernateCriteriaBuilder","date":"2018-01-28T02:13:00.000Z","path":"2018/01/28/Grails中神奇的HibernateCriteriaBuilder/","text":"Grails 中 HibernateCriteriaBuilder 用于动态为类构建一些常用的查询方法。 通过 metaClass 绑定方法，也就是 groovy 的 MOP 特性进行动态绑定方法。 HibernateCriteriaBuilder 派生于 AbstractHibernateCriteriaBuilder，AbstractHibernateCriteriaBuilder派生于GroovyObjectSupport。 其中 GroovyObjectSupport 实现了 GroovyObject 接口。 其中动态支持分页列表的实现在AbstractHibernateCriteriaBuilder中的invokeMethod有详细的说明。平时我们使用的时候只需要 键入 find 然后就会根据当前类的属性进行自动补全，你是要查询一条还是要查询多条记录，至于它的转化操作也定义在此，如图： grails.properties = params 绑定属性存在恶意风险，比如用户会伪造一些属性，从而导致类的一些属性修改被自动注入，影响到数据库中对应的表的具体记录。 具体的类图： 其中常用的方法接口定义在此：org.grails.orm.hibernate.IHibernateTemplate","tags":[{"name":"Grails","slug":"Grails","permalink":"http://baiwenhui.com/tags/Grails/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://baiwenhui.com/tags/Hibernate/"}]},{"title":"Grails-MVC示意图","date":"2018-01-08T14:21:00.000Z","path":"2018/01/08/Grails-架构示意图/","text":"使用 Grails 开发也有大半年了，现在对 Grails MVC 架构做个图示，加深理解记忆。Grails 使用 Spring MVC Web 应用程序作为底层框架来实现Web 应用程序基于模型-视图-控制器(MVC)模式。它包括三个核心的部分：控制器，Grails 域模型和Grails Servlet 页面。下面的图主要总结下这三个部分之间的关系。","tags":[{"name":"grails","slug":"grails","permalink":"http://baiwenhui.com/tags/grails/"},{"name":"grails mvc","slug":"grails-mvc","permalink":"http://baiwenhui.com/tags/grails-mvc/"},{"name":"groovy","slug":"groovy","permalink":"http://baiwenhui.com/tags/groovy/"}]},{"title":"Spring Security哈希认证记住我例子","date":"2017-11-16T16:19:00.000Z","path":"2017/11/17/Spring-Security哈希认证记住我例子/","text":"在本教程中，我们将演示如何使用Spring Security 创建通过哈希认证记住我的应用程序。请记住，身份验证是一项功能，它允许网站在会话之间记住用户的身份。Spring Security提供了两种记住我的实现。一种使用哈希来保存基于cookie的令牌的安全性，我们将在本教程中解决这个问题。第二种是使用数据库或其他永久存储机制来存储生成的令牌。 基于哈希令牌的方法记住我当用户启用记住我的身份验证时，会创建一个cookie并在后续登录时传递。这种方法使用散列来实现一个有用的记住我策略。该cookie的组成如下： 1234567base64(username + &quot;:&quot; + expirationTime + &quot;:&quot; +md5Hex(username + &quot;:&quot; + expirationTime + &quot;:&quot; password + &quot;:&quot; + key))username: As identifiable to the UserDetailsServicepassword: That matches the one in the retrieved UserDetailsexpirationTime: The date and time when the remember-me token expires, expressed in millisecondskey: A private key to prevent modification of the remember-me token 注意：记住我的记号只对指定的expirationTime和有效的username，password并且key不会改变。警告：这是一个潜在的安全问题。当记住我的令牌被恶意的用户代理捕获时，这个用户代理能够使用令牌直到它到期。如果需要更好的安全性，你应该使用这种persistent remember-me token方法。 项目结构我们先看看项目结构。 Maven的依赖我们使用Apache Maven来管理我们的项目依赖关系。确保以下依赖存在类路径中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.memorynotfound.spring.security&lt;/groupId&gt; &lt;artifactId&gt;hashing-remember-me&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;url&gt;https://memorynotfound.com&lt;/url&gt; &lt;name&gt;Spring Security - $&#123;project.artifactId&#125;&lt;/name&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- bootstrap and jquery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;3.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- testing --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Spring Security记住我哈希认证配置要想使记住我散列认证配置可用，我们需要在Spring中注册。在下一节中，我们将演示Java和XML配置。 SPRING JAVA配置在这里，我们正使用Java代码的方式配置记住我身份认证的配置。通过扩展我们的Spring配置类WebSecurityConfigurerAdapter，我们可以简单地配置记住我的身份验证configure(HttpSecurity http)方法。我们需要配置一个安全和唯一的密钥。这个密钥通常是一个强大而独特的密码。我们可以随意配置“记住我”cookie名称并设置令牌有效期。默认为2周。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.memorynotfound.spring.security.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.web.util.matcher.AntPathRequestMatcher;// 使用注解方式配置SpringSecurity记住我配置时，开启此注解@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring() .antMatchers( &quot;/js/**&quot;, &quot;/css/**&quot;, &quot;/img/**&quot;, &quot;/webjars/**&quot;); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login&quot;) .permitAll() .and() .logout() .invalidateHttpSession(true) .clearAuthentication(true) .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;)) .logoutSuccessUrl(&quot;/login?logout&quot;) .permitAll() .and() .rememberMe() .key(&quot;unique-and-secret&quot;) .rememberMeCookieName(&quot;remember-me-cookie-name&quot;) .tokenValiditySeconds(24 * 60 * 60); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication().withUser(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;); &#125;&#125; SPRING XML配置该文件spring-security-config.xml位于src/main/resources/文件夹中，是等效的Spring XML配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans:beans xmlns=&quot;http://www.springframework.org/schema/security&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;http&gt; &lt;intercept-url pattern=&quot;/login&quot; access=&quot;permitAll()&quot;/&gt; &lt;intercept-url pattern=&quot;/js/**&quot; access=&quot;permitAll()&quot;/&gt; &lt;intercept-url pattern=&quot;/css/**&quot; access=&quot;permitAll()&quot;/&gt; &lt;intercept-url pattern=&quot;/img/**&quot; access=&quot;permitAll()&quot;/&gt; &lt;intercept-url pattern=&quot;/webjars/**&quot; access=&quot;permitAll()&quot;/&gt; &lt;intercept-url pattern=&quot;/**&quot; access=&quot;isAuthenticated()&quot;/&gt; &lt;!--Spring Security 4.0以后默认开启宽展请求伪造保护，这里配置禁用，不安全的操作。--&gt; &lt;csrf disabled=&quot;true&quot;/&gt; &lt;form-login login-page=&quot;/login&quot;/&gt; &lt;logout invalidate-session=&quot;true&quot; logout-url=&quot;/logout&quot; logout-success-url=&quot;/login?logout&quot;/&gt; &lt;remember-me key=&quot;unique-and-secret&quot; remember-me-cookie=&quot;remember-me-cookie-name&quot; token-validity-seconds=&quot;86400&quot;/&gt; &lt;/http&gt; &lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;user-service&gt; &lt;user name=&quot;user&quot; password=&quot;password&quot; authorities=&quot;ROLE_USER&quot; /&gt; &lt;/user-service&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt;&lt;/beans:beans&gt; 创建控制器我们创建了一些简单的导航控制器 123456789101112131415161718package com.memorynotfound.spring.security.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class HomeController &#123; @GetMapping(&quot;/&quot;) public String greeting()&#123; return &quot;index&quot;; &#125; @GetMapping(&quot;/login&quot;) public String login() &#123; return &quot;login&quot;; &#125;&#125; 启动Spring我们使用Spring Boot来启动我们的应用程序。 123456789101112131415package com.memorynotfound.spring.security;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication// uncomment if you want to use Spring Security XML Configuration// 当使用xml的方式配置时，开启此注解注释掉Java代码方式的配置// @ImportResource(&quot;classpath:spring-security-config.xml&quot;)public class Run &#123; public static void main(String[] args) &#123; SpringApplication.run(Run.class, args); &#125;&#125; Thymeleaf模板我们用Thymeleaf来创建我们的视图。这些模板使用bootstrap和jquery，它们从org.webjars中加载。 创建登录页面该login.html页面位于该src/main/resources/templates文件夹中。在表单中我们创建了一个remember-me复选框。当用户启用记住我的身份验证时，cookie会传递给浏览器，该浏览器将以指定的时间到期。当用户在会话之间访问页面时，Spring Security会使用基于记住我的token自动认证。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/webjars/bootstrap/3.3.7/css/bootstrap.min.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/css/main.css&#125;&quot;/&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;h3&gt;&lt;i class=&quot;glyphicon glyphicon-lock&quot; style=&quot;font-size:2em;&quot;&gt;&lt;/i&gt;&lt;/h3&gt; &lt;h2 class=&quot;text-center&quot;&gt;Login&lt;/h2&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;div th:if=&quot;$&#123;param.error&#125;&quot;&gt; &lt;div class=&quot;alert alert-danger&quot;&gt; Invalid username or password. &lt;/div&gt; &lt;/div&gt; &lt;div th:if=&quot;$&#123;param.logout&#125;&quot;&gt; &lt;div class=&quot;alert alert-info&quot;&gt; You have been logged out. &lt;/div&gt; &lt;/div&gt; &lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt; &lt;input id=&quot;username&quot; name=&quot;username&quot; autofocus=&quot;autofocus&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt; &lt;i class=&quot;glyphicon glyphicon-lock&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; type=&quot;password&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt; &lt;input id=&quot;remember-me&quot; name=&quot;remember-me&quot; type=&quot;checkbox&quot;/&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success btn-block&quot;&gt;Login&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/webjars/jquery/3.2.1/jquery.min.js/&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/webjars/bootstrap/3.3.7/js/bootstrap.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建一个安全的页面该index.html页面位于src/main/resources/templates目录中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/webjars/bootstrap/3.3.7/css/bootstrap.min.css&#125;&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@&#123;/css/main.css&#125;&quot;/&gt; &lt;title&gt;Registration&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;h1&gt;Spring Security Remember Me Hashing Configuration Example&lt;/h1&gt; &lt;div sec:authorize=&quot;isRememberMe()&quot;&gt; The user: &lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; is logged in by &quot;Remember Me Cookies&quot;. &lt;/div&gt; &lt;div sec:authorize=&quot;isFullyAuthenticated()&quot;&gt; The user: &lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; is logged in by &quot;Username / Password&quot;. &lt;/div&gt;&lt;/div&gt;&lt;footer&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt; &amp;copy; Memorynotfound.com &lt;span sec:authorize=&quot;isAuthenticated()&quot; style=&quot;display: inline-block;&quot;&gt; | Logged user: &lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; | Roles: &lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt; | &lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;Sign Out&lt;/a&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/footer&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/webjars/jquery/3.2.1/jquery.min.js/&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/webjars/bootstrap/3.3.7/js/bootstrap.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 演示访问http://localhost:8080和页面被重定向到http://localhost:8080/login。 当用户和密码填写正确后，页面被重定向到http://localhost:8080/。 当检查我们的应用程序的cookie时，我们可以看到Spring创建了我们之前配置的remember-me-cookie-namecookie。 当您删除JSESSIONIDCookie并刷新页面时，当”remember-me“Cookie未过期时，您将自动登录。 参考 Spring Security Remember Me Documentation WebSecurityConfigurerAdapter JavaDoc RememberMeConfigurer JavaDoc 下载下载它 - spring-security-remember-me-hashing-authentication-configuration-example 原文链接：https://memorynotfound.com/spring-security-remember-hashing-authentication-example/","tags":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://baiwenhui.com/tags/SpringSecurity/"}]},{"title":"一行命令导入项目到IDEA","date":"2017-11-12T05:11:00.000Z","path":"2017/11/12/一行命令导入项目到IDEA/","text":"如何使用一行命令打开一个zip文件并导入项目到IDEA方法如下首先你得有我上次分享的那个idea打开项目的shell脚本。 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/sh# check for where the latest version of IDEA is installedIDEA=`ls -1d /Applications/IntelliJ\\ * | tail -n1`wd=`pwd`# were we given a directory?if [ -d &quot;$1&quot; ]; then# echo &quot;checking for things in the working dir given&quot; wd=`ls -1d &quot;$1&quot; | head -n1`fi# were we given a file?if [ -f &quot;$1&quot; ]; then# echo &quot;opening &apos;$1&apos;&quot; open -a &quot;$IDEA&quot; &quot;$1&quot;else # let&apos;s check for stuff in our working directory. pushd $wd &gt; /dev/null # does our working dir have an .idea directory? if [ -d &quot;.idea&quot; ]; then# echo &quot;opening via the .idea dir&quot; open -a &quot;$IDEA&quot; . # is there an IDEA project file? elif [ -f *.ipr ]; then# echo &quot;opening via the project file&quot; open -a &quot;$IDEA&quot; `ls -1d *.ipr | head -n1` # Is there a pom.xml? elif [ -f pom.xml ]; then# echo &quot;importing from pom&quot; open -a &quot;$IDEA&quot; &quot;pom.xml&quot; # can&apos;t do anything smart; just open IDEA else# echo &apos;cbf&apos; open &quot;$IDEA&quot; fi popd &gt; /dev/nullfi 然后使用如下脚本即可： 123456789101112fullFileName=$1suffix=$&#123;fullFileName#*.&#125;if [ &quot;$suffix&quot; != &quot;zip&quot; ];then echo &quot;Must be a valid zip file&quot;else filename=$&#123;fullFileName%.*&#125; echo &quot;filename: $filename&quot; echo &quot;now unzip $1 and use idea $1&quot; unzip $1 &amp;&amp; idea $filenamefi 将此脚本另存为uao.sh ， 放在合适的位置，然后建立一个软链，这里我把它放在此处/usr/local/bin/uao.sh，建立一个软链接ln -sf /usr/local/bin/uao.sh /usr/local/bin/uao。以后如果要将zip文件解压，打开idea，导入项目到idea这三个操作，直接使用这个脚本一行命令一步即可完成。赶快试试吧！","tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://baiwenhui.com/tags/IDEA/"}]},{"title":"使用淘宝镜像加速electron的下载","date":"2017-10-29T15:07:00.000Z","path":"2017/10/29/使用淘宝镜像加速electron的下载/","text":"目前github开源的electron库被好多桌面端应用广泛使用，有时候我们安装这类应用时特别慢，原因就是卡在了下载electron压缩包这个阶段，速度奇慢。为了不浪费我们宝贵的时间，使用下面的脚本可以帮助你分分钟下载成功electron，感谢淘宝npm镜像。 1export ELECTRON_MIRROR=\"https://npm.taobao.org/mirrors/electron/\"","tags":[{"name":"electron","slug":"electron","permalink":"http://baiwenhui.com/tags/electron/"}]},{"title":"groovy中的each坑小记","date":"2017-10-26T07:29:00.000Z","path":"2017/10/26/groovy中的each坑小记/","text":"前言Java编程中，如果要跳出for循环，直接使用break即可。但是在groovy的each方法中，如果使用break，则程序在运行时就会报如下错误：the break statement is only allowed inside loops or switches。 如何跳出each循环呢？ groovy的each方法是一个闭包操作，如果想跳出循环，则可以使用return true。 但是存在一个问题：就是这里的return true并不完全等价于java for循环中的break操作。它更像是java for循环中的continue操作，跳出当前循环，继续下一次循环。至于这里的原因，有待研究。 诡异的产生 当使用“==”操作符号进行比较时，return true等价于java for循环中的continue，但如果是“&gt;=” 操作符的话，等价于java for循环中的break操作。测试代码如下： 1234567891011121314151617181920212223def a = [1, 2, 3, 4]println &quot;each loop break use groovy&quot;a.each &#123; // groovy each 循环中的return true类似于java for循环中的continue // 当遍历的元素等于2时，跳过当前元素，继续执行, 如果写&gt;= 时，的确也等价于break if (it &gt;= 2) return true // break println it // do the stuff that you wanted to before break&#125;println &quot;for loop break use java&quot;for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] == 2) &#123; // java for 循环中的break直接跳出当前循环 // 当遍历的元素等于2时，直接跳出循环 break &#125; println a[i]&#125; 这便是groovy中的each闭包方法的诡异之处，奇怪的是，如果你对集合元素使用find方法遍历，当比较操作符是“==”时，并不会发生以上的问题，测试代码如下：1234567def a = [1, 2, 3, 4, 5, 6, 7]a.find &#123; if (it == 3) return true // break 此时的break等价于java for循环中的break println it return false // 继续循环&#125; 建议 当对遍历的元素进行迭代，并且在迭代的过程中需要跳出当前循环的，推荐使用groovy的find方法或者使用java的for循环，不要使用groovy的each方法，这样就可以保证流程控制没有错误。","tags":[{"name":"groovy","slug":"groovy","permalink":"http://baiwenhui.com/tags/groovy/"}]},{"title":"Mac下使用jenvs安装Java9","date":"2017-10-23T08:36:00.000Z","path":"2017/10/23/Mac下使用jenvs安装Java9/","text":"JDK9已经距离现在发布了好一段时间了，如果你还没有尝试一下，建议安装体验体验！一般情况下，我们的PC上基本都会安装多个版本的JDK，此时我们为了多个JDK版本的切换，这里，强烈推荐使用jenvs,关于具体使用请参考作者的详细介绍。这里不多做介绍。 已经安装了jenvs的同学，则跳过上面的内容，直接看下面内容–如何将JDK9添加到jenvs的管理中。 1.下载JDK9 2.安装完毕后，只需要打开终端做如下操作即可（jdk9安装完毕后，默认在mac系统的/Library/Java/JavaVirtualMachines/）：1jenv add /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home 3.以上操作执行完毕后，会得到如下提示：123oracle64-9.0.1 added9.0.1 added9.0 added 4.切换Java91jenv shell 9.0.1 5.此时我们便可以使用jenv进行切换，尝试使用java9的新特性了！","tags":[{"name":"java","slug":"java","permalink":"http://baiwenhui.com/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"http://baiwenhui.com/tags/jdk/"}]},{"title":"阿里巴巴Java开发规约的IDEA插件使用","date":"2017-10-16T01:21:00.000Z","path":"2017/10/16/阿里巴巴Java开发规约的IDEA插件使用/","text":"作者：不想当码农的程序员 原文：http://www.jianshu.com/p/2f271e6d675c编辑：Moon 就在10月15日上午9：00，阿里巴巴在杭州云栖大会《研发效能峰会》上，正式发布《阿里巴巴Java开发手册》扫描插件，该插件在扫描代码后，将不符合《手册》的代码按 Blocker/ Critical/ Major三个等级显示在下方，甚至在IDEA上，还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能。 Git地址为：https://github.com/alibaba/p3c IDea的安装方式：IDEA版的插件发布到了IDEA官方仓库中(最低支持版本14.1.7，JDK1.7+)，只需打开 1Settings &gt;&gt; Plugins &gt;&gt; Browse repositories 输入 Alibaba 搜索一下便可以看到对应插件了，点击安装等待安装完成。 如图: 这里写图片描述 Eclipse的安装方式：Eclipse版插件支持4.2（Juno，JDK1.8+）及以上版本，提供Update Site，通过 1Help &gt;&gt; Install New Software 然后输入 https://p3c.alibaba.com/plugin/eclipse/update即可看到安装列表，安装即可。 插件的更新，可以通过 Help&gt;&gt;CheckforUdates 进行新版本检测。 怎么用呵呵 右键，，看图 – 还有自动提示的效果 可以说是非常棒了 推荐阅读 程序员你为什么这么累【续】：如何应对需求变更 Spring4All社区正式招募Spring Guides翻译小分队~ 海外IT工程师工作福利揭秘 一个不可思议的MySQL慢查分析与解决 都在说微服务，那么微服务的反模式和陷阱是什么 长按指纹 一键关注","tags":[{"name":"工具","slug":"工具","permalink":"http://baiwenhui.com/tags/工具/"}]},{"title":"Spring官方周报20171003","date":"2017-10-09T12:41:00.000Z","path":"2017/10/09/Spring官方周报20171003/","text":"@strongant &amp; @chenzhijun &amp; @maskwang 翻译 欢迎收看新一期 《Spring 周报》！周报包含了上周的很多内容，可以了解非常多的干货。现在 Spring Framework 5.0 已推出！Spring Framework 5.0 同时也带来了许多发行版本，在本文中你会知道有哪些版本。另外，本周我(Josh Long)和其他来自Pivotal和Spring的团队成员，都会出席JavaOne大会，希望您能来我们的展位找我们或者和我们一起参与讨论。 https://spring.io/blog/2017/09/28/pivotal-and-spring-team-at-javaone-2017 以下是关于周报的内容： 上周，我研究了一下怎么使用 Spring Framwork5 来构建基于 websocket 的响应式应用: https://spring.io/blog/2017/09/27/spring-tips-reactive-websockets-with-spring-framework-5 Spring AMQP 和 Spring Integration 开发组领导 Gary Russell 宣布发布 Spring AMQP 2.0.RC2: https://spring.io/blog/2017/09/27/spring-amqp-2-0-release-candidate-2-available 经过一段长的时间，Spring Framework 5.0.GA现在终于发布了！新版本集成了 Reactor 项目，包括响应式 web 运行时环境，Kotlin 扩展，以及全面基于 Java EE 7 和 Java 8。新的发行版包含了太多的新东西,如果想要知道更多的消息，查看版本说明，然后查看更新内容: https://spring.io/blog/2017/09/28/spring-framework-5-0-goes-ga https://github.com/spring-projects/spring-framework/wiki/What&#39;s-New-in-the-Spring-Framework#whats-new-in-spring-framework-5x Spring Reactor 团队成员 Simon Baslé 宣布发布 Spring 和 Reactor 集成的新版本Reactor Bismuth。这个版本为 Spring Framework 5.0 奠定了基础，它自己本身也包含了非常多的功能: https://spring.io/blog/2017/09/28/reactor-bismuth-is-out Spring Framework 5.0 版本更新了一些其他的项目，其中包括发布了 Spring Data Kay。自从 Spring Data 于2009年成立以来，这是 Spring Data 更新的最大版本！该新版本以 Spring Framework 5.0 ，Java 8 和 Java EE 7 作为基准。它包括一个改进的仓储(repository) API（完整支持Optional&lt;T&gt;），支持响应式数据访问（Cassandra，Couchbase，MongoDB和Redis），新发布版本新增 Spring Data Geode，使用非空注解并且优化了运行时检查空注解，通过 Kotlin 构造方法，支持 Kotlin 的 null安全和不可变数据类，支持兼容 Java 9，如果想了解更多请看 Spring Data Kay 文档: https://spring.io/blog/2017/10/02/spring-data-release-train-kay-goes-ga Spring 消息中间件团队成员 Artem Bilan 宣布发布 Spring for Apache Kafka 2.0.GA。新版本包括支持 Apache Kafka，支持事务，消息头匹配，Apache Kafka 的Streams 支持，新的 KafkaAdmin，增加 @KafkaListener 和 Consumer 错误处理和群组支持的方案。它还支持使用 @EmbeddedKafka 进行测试: https://spring.io/blog/2017/10/02/spring-for-apache-kafka-2-0-ga-available Spring Cloud 团队成员 Ryan Baxter 宣布发布 Spring Cloud Dalston SR4。新版本更新了 Spring Cloud Contract，Spring Cloud Config，Spring Cloud Commons，Spring Cloud Netflix和Spring Cloud Sleuth: https://spring.io/blog/2017/10/03/spring-cloud-dalston-sr4-is-now-available Spring REST Docs 开发领导者 Andy Wilkinson 宣布发布 Spring REST Docs 1.2.2.RELEASE 。这个维护版本包括一些错误修复和文档的改进，推荐大家升级: https://spring.io/blog/2017/09/28/spring-rest-docs-1-2-2-release 查看 Spring Framework 5 的全新的通过构造方法实现注解的实现: https://github.com/spring-projects/spring-framework/commit/23497a7ece7aac1591187b46f4b601d2f48764e0 德语访谈中 Andreas Falk 提到的 Spring Framework 5.0 和 Spring Security 5.0 中的新功能: https://jaxenter.de/spring-security-interview-falk-62685 由 Zoltan Altfatter 发表的这篇文章介绍了如何在 Spring Integration 流程中引入一个新的JMS消息来启动 Spring Batch 作业: http://blog.mimacom.com/blog/2017/09/29/trigger-a-spring-batch-job-with-a-jms-message/ Rohit Kelapure: 为什么 Pivotal 公司的 Cloud Foundry 是运行 Spring Boot 应用程序的最佳选择？ https://twitter.com/rkela/status/914924780373073920 在这篇文章中，Cristina Negrean 介绍了如何使用 Spring Cloud Data Flow 进行实时分析： https://cristinanegrean.github.io/2017/10/01/spring-cloud-dataflow-for-real-time-analytics-with-twitter-api Gabriela Motroc 在 JAXEnter 网上发布了一篇关于 Spring Framework 5 的新文章。非常多的功能都在文章包含了: https://jaxenter.com/spring-framework-5-0-137677.html Aboullaite Mohammed：使用 Elasticsearch 和 Kibana 和 Spring Boot 集合来监控一些指标: https://aboullaite.me/spring-boot-elastic-kibana/ Ordina JWorks：使用 Spring Cloud 来对微服务进行安全防护: https://ordina-jworks.github.io/microservices/2017/09/26/Secure-your-architecture-part1.html","tags":[{"name":"Spring官方周报翻译","slug":"Spring官方周报翻译","permalink":"http://baiwenhui.com/tags/Spring官方周报翻译/"}]},{"title":"Grails中序列化json出现异常数据","date":"2017-09-29T09:24:00.000Z","path":"2017/09/29/Grails中序列化json出现异常数据-md/","text":"Httpbuilder 是一个基于groovy简单的HTTP客户端工具。它基本支持常用的几种HTTP请求方式(GET,PUT,POST,DELETE,HEAD,PATCH)。 发生解析url值异常项目环境：| Grails Version: 3.0.7| Groovy Version: 2.4.4| JVM Version: 1.8.0_121 由于是使用post方式给对方推送数据，所以我们先模拟一个请求服务，使用grails快速创建一个项目，然后编写一个方法，用于处理post请求，在后端输出接收到的具体数据是什么。步骤如下： 1.进入我的目录/Users/bwh/study/grails 生成一个grails的项目1cd /Users/bwh/study/grails &amp;&amp; cd $_ &amp;&amp; grails create-app test111 使用grails脚手架生成项目，如果没有产生其他异常，一般情况下我们会得到如下提示：1| Application created at /Users/bwh/study/grails/test111 2.进入刚才生成的项目中，由于本地已经使用了8080端口，修改grails项目的默认端口：在/Users/bwh/study/grails/test111/grails-app/conf/application.yml 修改默认的8080端口，修改如下123456---...# 修改项目默认端口8080为7070server: port: 7799... 3.打开项目，在当前项目的controllers目录下新建一个测试Controller，暂时叫做TestController，使用如下脚本进行生成相应的Controller文件，其当前目录结构如下：1234567891011121314...├── grails-app│ ├── assets│ │ ├── images│ │ ├── javascripts│ │ └── stylesheets│ ├── conf│ │ ├── application.yml│ │ ├── logback.groovy│ │ └── spring│ ├── controllers│ │ ├── TestController.groovy│ │ └── UrlMappings.groovy... 4.还原现场,在刚才新建的TestController中添加此方法，用于接收对方传递过来的数据：1234567def postReport() &#123; println params def jsonObject = request.JSON println &quot;jsonObject: $&#123;jsonObject&#125;&quot; println &quot;jsonObject String: $&#123;jsonObject as JSON&#125;&quot; render([code: 10000, msg: &quot;测试获取数据!&quot;, data: params] as grails.converters.JSON) &#125; 5.启动项目1grails run-app 用于接收post请求的测试服务已经启动完毕，接下来修改响应的推送地址进行发送数据即可。相关测试代码：1234567891011121314151617#Test.groovyimport groovyx.net.http.ContentTypeimport groovyx.net.http.HTTPBuilderimport static groovyx.net.http.Method.POSTdef baseURL = &quot;http://localhost:7799/test/postReport&quot;def data = [&quot;url&quot;: &quot;http://$&#123;baseURL&#125;/test/postReport&quot;]def client = new HTTPBuilder(baseURL)client.request(POST, ContentType.JSON) &#123; body = data response.success = &#123; resp, json -&gt; println &quot;resp: $&#123;resp&#125;&quot; println &quot;success data: $&#123;json&#125;&quot; &#125; response.failure = &#123; resp, json -&gt; println &quot;resp:$&#123;resp&#125;&quot; println &quot;failure data: $&#123;json&#125;&quot; &#125;&#125; 运行测试代码后，发现测试服务端收到如下结果： 1jsonObject String: &#123;&quot;url&quot;:&#123;&quot;valueCount&quot;:1,&quot;strings&quot;:[&quot;http://&quot;,&quot;/test/postReport&quot;],&quot;bytes&quot;:[104,116,116,112,58,47,47,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,55,55,57,57,47,116,101,115,116,47,112,111,115,116,82,101,112,111,114,116,47,116,101,115,116,47,112,111,115,116,82,101,112,111,114,116],&quot;values&quot;:[&quot;http://localhost:7799/test/postReport&quot;]&#125;&#125; 可以发现url是被转换成一个字符数组了，为什么呢？通过跟踪源码，发现它的body数据构造位于此方法：123456789101112131415protected Object doRequest( URI uri, Method method, Object contentType, Closure configClosure ) throws ClientProtocolException, IOException &#123; HttpRequestBase reqMethod; try &#123; reqMethod = method.getRequestType().newInstance(); // this exception should reasonably never occur: &#125; catch ( Exception e ) &#123; throw new RuntimeException( e ); &#125; reqMethod.setURI( uri ); RequestConfigDelegate delegate = new RequestConfigDelegate( reqMethod, contentType, this.defaultRequestHeaders, this.defaultResponseHandlers ); configClosure.setDelegate( delegate ); configClosure.setResolveStrategy( Closure.DELEGATE_FIRST ); configClosure.call( reqMethod ); return this.doRequest( delegate ); &#125; 其中函数执行到configClosure.call( reqMethod )方法时，其代理对象的body值为GStringImpl对象。由此可以判断，对map中的对象类型数据没有进行转换，因此出现了以上问题。 解决办法，使用groovy自带的json序列化类JsonBuilder进行将map对象先序列化成字符串然后再传递即可。修改后测试代码如下：12345678910111213141516171819import groovy.json.JsonBuilderimport groovyx.net.http.ContentTypeimport groovyx.net.http.HTTPBuilderimport static groovyx.net.http.Method.POSTdef baseURL = &quot;http://localhost:7799/test/postReport&quot;def data = [&quot;link&quot;: &quot;http://$&#123;baseURL&#125;/test/postReport&quot;]def dataString = new JsonBuilder(data).toString()def client = new HTTPBuilder(baseURL)client.request(POST, ContentType.JSON) &#123; body = dataString response.success = &#123; resp, json -&gt; println &quot;resp: $&#123;resp&#125;&quot; println &quot;success data: $&#123;json&#125;&quot; &#125; response.failure = &#123; resp, json -&gt; println &quot;resp:$&#123;resp&#125;&quot; println &quot;failure data: $&#123;json&#125;&quot; &#125;&#125;","tags":[{"name":"grails, JsonBuilder","slug":"grails-JsonBuilder","permalink":"http://baiwenhui.com/tags/grails-JsonBuilder/"}]},{"title":"Spring官方周报20170926","date":"2017-09-27T13:45:00.000Z","path":"2017/09/27/Spring官方周报20170926/","text":"strongant &amp; maskwang 翻译嗨,亲爱的Spring粉丝们！又是一个疯狂美妙的一周！我回到旧金山，与客户和当地合作伙伴谈论关于Pivotal相关的所有事情，同时在旧金山的阳光下享受玩Java 9的乐趣。我非常喜欢，并期待着这个新的版本，当然，Spring Framework 5是开箱即用的，它使用了Java 9。 https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6 1: Spring IO平台领导Andy Wilkinson刚刚宣布了Spring IO Platform Brussels SR5。新版本包括Spring AMQP 1.7.4，Spring Boot 1.5.7，Spring Data Ingalls SR7，Spring Framework 4.3.11，Spring Integration 4.3.12，Spring Loaded 1.2.8和Spring Web Flow 2.4.6。在这个新版本中，很多东西是这样的，所以现在就开始吧！ https://spring.io/blog/2017/09/19/spring-io-platform-brussels-sr5 2: Spring工具套件主管Martin Lippert刚刚发布了在MacOS High Sierra 10.13上运行STS时如何避免一些问题。 https://spring.io/blog/2017/09/21/how-to-get-sts-eclipse-running-on-macos-high-sierra-10-13 3: Spring Cloud Task 的领导 Michael Minella刚刚宣布了Spring Cloud Task 1.2.2.RELEASE。新版本增加了对Spring Framework最近对使用MySQL的序列表的除MYISAM之外的数据库引擎的支持。 https://spring.io/blog/2017/09/25/spring-cloud-task-1-2-2-release-is-now-available 4: 经典的Spring PetClinic多年来发生了很大变化！该版本演示了与Spring和Kotlin的PetClinic。如果你曾经看过任何一个原始的PetClinics（其中许多早于Spring本身！），你会觉得这是一个非常简洁的小应用程序， https://github.com/spring-petclinic/spring-petclinic-kotlin 5: 想了解Spring Boot的功能？这份分析报告可能是指南清单！ https://content.pivotal.io/analyst-reports/spring-boot-simplifies-end-to-end-development?_lrsc=7c3f3dc7-c1fa-4e7b-863f-615b5abb2c52 6: Spring Cloud Pipelines 现在也支持Kubernetes http://cloud.spring.io/spring-cloud-pipelines/multi/multi_jenkins-pipeline-k8s.html#_connecting_to_a_kubo_cluster 7: Oracle发布Java 9！这是一个很大的事情！在Java 9中有很多好处。如果不使用Java 9，请尝试一下Spring Framework 5，Spring Framework 5在Java 9（模块和类路径）上运行，没有任何问题。 https://www.infoq.com/news/2017/09/Java-9-release-sept-21 8: Twitter上的Alex Falappa发表：“下一个牛逼的SpringBoot插件：用于检测和修复丢失的pom依赖关系的java编辑器提示https://t.co/n7w22q4sMK” https://twitter.com/aless_falappa/status/912735050093010944 9: 最近有人询问有关在Cloud Foundry的Spring Boot应用程序中演示mTLS身份验证的示例。我不知道，所以 - 我经常这样做 - 我问Spring Security的主管Rob Winch，他分享了Java Cloud Foundry经验领导Ben Hale这个惊人的例子。很有意思！ https://github.com/nebhale/mtls-sample 10: 我喜欢这个博客关于Pivotal领域的首席技术官Josh McKenty和他所在的云和云构建 https://www.youtube.com/watch?v=OfwDTYeqHcI 11: 新的RebelLabs开发人员生产力报告已经出炉，并显示出Spring持续强劲增长。 Spring有众多用户，占46％，而Java EE则占33％。它也显示了Java 8的惊人增长，72％的用户使用它。哈哈，这两个好消息！ https://zeroturnaround.com/rebellabs/developer-productivity-report-2017-why-do-you-use-java-tools-you-use/ 12: 新的Microsoft和新的Microsoft SQL Server 2017版本在这里，它运行在Linux上！我从来没有想过我会看到这一天。这与Spring有什么关系？绝对没有。只是..它真的很酷！ https://arstechnica.com/gadgets/2017/09/microsoft-ignite-2017-azure-sql/?amp=1 13: 您在Spring Framework 5的功能Web框架中看到了7月份的活动中Spring大牛Arjen Poutsma的网络研讨会的成果？ https://www.brighttalk.com/webcast/14893/263393?_lrsc=b02b5b66-1acb-44bc-8a09-1f23cdc47bf2 14: 说到响应式，你也可以欣赏Evgeny Poberezkin关于响应式编程演变的这个演讲。 https://www.infoq.com/presentations/reactive-programming-evolution 15: Oracle有一个很好的选择了一些内容，引入了Java 9中的新功能。看看吧！ https://www.oracle.com/java/java9-screencasts.html 16: Spring社区朋友迈克尔·西蒙斯（Michael Simons）介绍了Spring Boot的新版德语书籍。快去一探究竟！ https://www.amazon.de/dp/3864905257/ref=cm_sw_r_tw_api_1.zXzbGMMWCEC 17: 最新版本的Camunda BPM系统具有Spring Boot集成功能。 https://github.com/camunda/camunda-bpm-spring-boot-starter/ 18: .NET大牛Richard Seroter表示，Java和Spring Cloud用户对如下会觉得无趣：学习如何使用Pivotal的Steeltoe框架将断路器集成到.NET应用程序中。 https://seroter.wordpress.com/2017/09/21/adding-circuit-breakers-to-your-net-applications/amp/ 19: 织机系统将Pivotal Cloud Foundry和Pivotal集装箱服务（基于Kubernetes）进行了环境化。 https://www.loomsystems.com/blog/everything-you-need-to-know-about-pks-in-3-acts?_lrsc=ae2c4d5a-294e-4484-8ea8-e6beccfc4caa 20: Jenn Strater - 一个Spring REST文档的专家，除了许多其他内容之外，还汇集了一个介绍测试驱动文档的精彩演示文稿（根据Spring REST文档，natch）。 https://speakerdeck.com/jlstrater/test-driven-docs-apiconf-de-2017 21: IBM最近发布了他们的J9 JVM。这篇文章让你对J9这个名字背后的独特历史有一点了解。 https://medium.com/@rservant/how-did-the-j9-in-openj9-get-its-name-95a6416b4cb9?source=userActivityShare-a17df5ec14a4-1505939701 22: 这篇文章关于API文档的十个好主意与Spring并没有任何关系，但它似乎强调了这一点：Spring REST文档是一个好主意（TM）！ https://alistapart.com/article/the-ten-essentials-for-good-api-documentation","tags":[{"name":"翻译","slug":"翻译","permalink":"http://baiwenhui.com/tags/翻译/"},{"name":"Spring周报","slug":"Spring周报","permalink":"http://baiwenhui.com/tags/Spring周报/"}]},{"title":"算法中的反转","date":"2017-09-17T05:27:55.000Z","path":"2017/09/17/算法中的反转/","text":"前言一般工作中，可能不会自己去实现元素反转的操作。因为目前的高级语言基本已经帮我们实现好了，我们要做的就是使用好相关的函数就可以了。但是对于知识的认知不能只停留在表面，有些时候更需要去寻求底层的实现原理，这样一来，对于我们自身能力的提高有很大帮助! 数组元素的反转有n个元素的数组，我们可以得到该数组的大小。需要做的就是把第一个元素和最后一个元素进行调换位置即可，对于奇数数组和偶数数组处理类似。只不过奇数数组我们不用管中间的那个元素，比如奇数数组处理思路如下： int[] oddArray = new int[]{ 1, 2, 3 }; 反转这个数组的方法只需要进行将索引为0的1和索引为2的3元素进行位置的调换即可完成。 偶数数组处理思路如下： int[] oddArray = new int[]{ 1, 2, 3, 4 }; 同奇数的处理思路一样，将数组索引为0的元素与索引为3的元素换位，将索引为1的元素与索引为2的元素进行换位。 明白了以上的解决思路，写代码就简单了，具体的实现方案如下： 123456789101112class Solution&#123; private static void reverseArray(int[] array) &#123; final int len = array.length - 1; final int mid = array.length &gt;&gt; 1; for (int i = 0; i &lt; mid; i++) &#123; final int temp = array[len - i]; array[len - i] = array[i]; array[i] = temp; &#125; &#125;&#125; 单链表元素的反转1.什么是链表？ 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。——-摘抄自维基百科 2.定义链表数据结构 通过概念我们可以了解到，链表的结构应该包含当前节点的值，和指向下一个节点的指针元素。那么，便可以对其数据结构做如下定义： 123456789101112131415161718class ListNode &#123; int val; ListNode next; ListNode(int val)&#123; this.val = val; &#125; @Override public String toString() &#123; return &quot;ListNode&#123;&quot; + &quot;val=&quot; + val + &quot;, next=&quot; + next + &apos;&#125;&apos;; &#125;&#125; 3.初始化链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LinkedListReverse &#123; public static void main(String[] args) &#123; int count = 9; ListNode t = initListNode(count,count); printLinkedList(t); &#125; private static ListNode initListNode(int len , int count) &#123; ListNode t = new ListNode(1); ListNode x = t; for(int i = 2; i &lt;= len; i++)&#123; // x 用于指向新创建的节点，将新创建的节点指向当前节// 点的下一个引用 x = (x.next = new ListNode(i)); &#125; return t; &#125; private static void printLinkedList(ListNode head) &#123; ListNode node = head; while(node != null)&#123; System.out.println(node.val); node = node.next; &#125; &#125;&#125;class ListNode &#123; int val; ListNode next; ListNode(int val)&#123; this.val = val; &#125; @Override public String toString() &#123; return &quot;ListNode&#123;&quot; + &quot;val=&quot; + val + &quot;, next=&quot; + next + &apos;&#125;&apos;; &#125;&#125; 通过以上的方式我们创建了一个从1到9的单向链表。 4.反转单链表 反转思路：这个实现的思路和数组元素的反转类似，只不过需要做一点稍微的变化，我们知道单链表的最后一个元素指向null,有1-10之间的元素链表,只需要将值为1的节点引用指向null,值为2的节点引用指向1，以此类推，根据以上分析可以得到以下方法，暂且将方法命名为 reverse ，方法实现如下：1234567891011121314public static ListNode reverse(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while (curr != null) &#123; //save next node ListNode nextTemp = curr.next; //change curr.next = prev; //cache prev node prev = curr; curr = nextTemp; &#125; return prev; &#125; 关于反转的详细思路结合reverse方法参考如下分析过程：12345678910111213141516171819202122232425262728293031323334353637383940414243/*单链表反转分析过程：1-&gt;2-&gt;3-&gt;4prev = nullcurr = head(值为1的节点)nextTemp -&gt; next (值为2的节点)curr.next = prev(当curr的值为1时，它的next为null)设置完毕后，将当前节点(值为1的节点)缓存起来，供下一次循环到的节点进行使用prev -&gt; curr最后，将当前节点的引用指向 next (值为2的节点)第一次循环之后，可以得到如下数据：2--&gt;1--&gt;null第二次循环此时，curr是值为2的节点nextTemp -&gt; next (值为3的节点)curr.next = prev(当curr的值为2时，它的next为prev，即：next指向上一次循环时缓存下来的值为1的节点)再讲prev引用指向当前遍历的值为2的节点，供下一次循环使用,即prev = curr (值为2的节点)接着将当前值为2的节点指向值为3的节点第二次循环之后，结果变为：3-&gt;2-&gt;1-&gt;null以此类推，当遍历到节点为4的值时，curr=null，循环结束，具体结果为：4-&gt;3-&gt;2-&gt;1-&gt;null通过以上的分析，可以深刻理解单链表的反转操作套路。*/ Java实现数组元素的反转demo https://gist.github.com/strongant/7e2baab6291a569586bab1b97b0b22c6 Java实现单链表的反转demo https://gist.github.com/strongant/f31727433ce0af4d2f6afb14ff304a19","tags":[{"name":"算法","slug":"算法","permalink":"http://baiwenhui.com/tags/算法/"}]},{"title":"使用Httpie来替代CURL","date":"2017-09-10T13:51:00.000Z","path":"2017/09/10/使用Httpie来替代CURL-1/","text":"当下的一些比较人们的测试接口的客户端工具大概有以下几种： Postman（使用最多，一个基于Chrome的app） CURL（在终端下工作的文件传输工具） Httpie（终端下比较友好、简洁、特性更多，功能更强大） 个人在终端下比较推荐使用Httpie，原因如下： 举个例子，如果我们发起一个请求，获取一个JSON字符串，如果我们使用CURL进行获取的话，需要使用管道命令结合python自带的json.tool这个脚本才能完成，curl https://httpbin.org/get | python -m json.tool 如果我们使用Httpie的话，只需要这样：http https://httpbin.org/get,可以发现它不仅返回了body内容，也同时返回了header信息。当然如果我们只需要看body内容，此时只需要进行筛选即可，使用如下命令请求即可：http https://httpbin.org/get --body,如果只需要header信息，可以这样：http https://httpbin.org/get --header。更多特性，请参考：https://httpie.org/ Httpie默认会将返回的JSON数据进行格式化，不再需要二次转换，并且它会使用颜色将一些不同类型的数据加以区分，这样也方便我们进行查看。 这里介绍下Mac下的安装方式：由于Httpie依赖Python，一般情况下Mac下已经自带了Python环境，只不过版本可能并不是最新的。使用brew安装即可： 1brew install httpie 安装成功后我们进行测试是否可用：1http ifconfig.me/all.json 正常情况下便可以得到带颜色的格式良好的JSON数据。","tags":[{"name":"工具","slug":"工具","permalink":"http://baiwenhui.com/tags/工具/"}]},{"title":"官方Spring周报-20170905","date":"2017-09-07T14:31:00.000Z","path":"2017/09/07/官方Spring周报-20170905/","text":"Spring的粉丝们，欢迎来到本周的另一期官方周报！这个星期我在香港看这个惊人的YOW！然后是新加坡的YOW。这些会议都是来自澳大利亚顶尖的会议，而且会议很新颖。如果你在这两个地方，我希望你会来。 http://www.yowconference.hk/ http://www.yowconference.sg/ 1.介绍下关于Spring Cloud Data Flow最重要的一个方面。 Spring Cloud Data Flow大牛Eric Bottard首先介绍了Spring Cloud Data Flow Shell本身。 https://spring.io/blog/2017/08/29/spring-cloud-data-flow-tips-tricks-interacting-with-the-shell 2.Spring Cloud贡献者Ryan Baxter刚刚宣布了Spring Cloud Edgeware M1 的发布。新版本包括对各种项目的更新以及新的Spring Cloud Gateway项目。此版本基于Spring Boot 1.5.x。 https://spring.io/blog/2017/08/29/spring-cloud-edgware-m1-is-now-available 3.Spring Cloud联合创始人Spencer Gibb刚刚宣布了Spring Cloud Finchely M2的发布。这个新版本基于Spring Boot 2.0.x，所以是基于Java 8。它还支持Spring Cloud Gateway中更多更酷的功能。在Spring Cloud Gateway和其他版本中，一个常见主题是反应性支持。 https://spring.io/blog/2017/08/30/spring-cloud-finchley-m2-is-available 4.Spring Cloud Flow大牛Thomas Risberg在本文中介绍了针对Kubernetes的Spring Cloud Data Flow的Helm安装程序。 Helm是Kubernetes的包管理者。 https://spring.io/blog/2017/08/31/simple-installation-of-data-flow-for-kubernetes-with-helm 5.这个应用现代化的Pivotal和Apigee白皮书是一个很好的阅读题材。 https://content.pivotal.io/apigee/application-modernization?_lrsc=9d76ba9e-eb43-42fb-b85d-9e5b48373ac4 6.Matt McCandless称Spring Boot老而弥新，这是个很好的起步。 https://dzone.com/articles/spring-boot-the-right-boot-for-you-1 7.这篇关于使用Spring Boot的Quartz Scheduler的文章是曾经看过的一篇文章。我喜欢。 http://www.opencodez.com/java/quartz-scheduler-with-spring-boot.htm 8.看起来要想Java 9发布，这个新的Java版本将会有6个月的时间。我个人欢迎新版本。 https://jcp.org/aboutJava/communityprocess/ec-public/materials/2017-08-15/JCP-EC-Minutes-August-2017.html 9.我真的很喜欢这个俄语的帖子，介绍Spring Boot的应用程序开发。 https://alexkosarev.name/2017/08/08/application-development-with-spring-part-1/ 10.上周Pivotal与Google和VMWare合作，宣布了Pivotal Cloud Foundry生态系统 - Pivotal Container Service - 由BOSH管理的Kubernetes服务的下一步工作。我们从TechCrunch片中得到一些细节。 https://www.blog.google/topics/google-cloud/vmware-and-pivotal-launch-new-hybrid-kubernetes-solution-optimized-gcp/ https://techcrunch.com/2017/08/29/seven-moves-that-led-to-the-vmware-pivotal-google-partnership/amp/ 11.我喜欢这个Auth0在集成Spring Boot与SQL数据库（PostgreSQL），JPA和Liquibase。 https://auth0.com/blog/integrating-spring-data-jpa-postgresql-liquibase/ 12.来自JHipster的这篇关于“API优先开发”的文章很有趣。 http://www.jhipster.tech/doing-api-first-development/ 13.Spring Boot 2.0具有反应弹性框架5和Java 8基准线，肯定会令人印象深刻。新版本中我最喜欢的功能之一就是支持Spring Boot Actuator端点的REST-stack（响应式Spring WebFlux，Spring MVC或JAX-RS）。 https://www.infoq.com/news/2017/08/spring-boot-2-actuator-endpoints 14.看看这个优秀的网络研讨会，了解为什么IntelliJ IDEA是Grails应用程序的首选。我喜欢这个，因为Grails 3是基于Spring Boot的，因为Jeff Scott Brown是一个伟大的演讲者，因为IntelliJ做了一个漂亮的好IDE。 https://blog.jetbrains.com/idea/2017/07/webinar-recording-why-intellij-idea-is-the-premier-ide-for-grails-3/ 15.严格来说，这与Spring不是很相关，但它是值得一读的。丹尼尔·布莱恩特（Daniel Bryant）在这篇文章中描述了测试微服务（以及您可能使用的所有组件）的全方位方法。 https://specto.io/blog/2016/8/16/recipe-for-designing-building-testing-microservices/ 16.我喜欢这个来自Spring Data的StackOverflow响应Oliver Gierke：如何在Spring Boot中选择性升级依赖项？ https://stackoverflow.com/questions/45967464/how-to-selectively-upgrade-a-dependency-in-spring-boot-sample-case-spring-dat 17.如果您想快速了解一下Cloud Foundry服务代理商，请阅读本文。 http://www.automate-it.today/about-cloud-foundry-service-brokers/ 18.这篇也不是严格来说与Spring有关，但对于构建云原生应用程序的一些Spring用户来说，这对于Java云主机服务的成本降低策略来说非常有用。 https://www.infoq.com/articles/java-cloud-cost-reduction","tags":[{"name":"Spring官方周报","slug":"Spring官方周报","permalink":"http://baiwenhui.com/tags/Spring官方周报/"}]},{"title":"Java 微服务实践- Spring Boot 系列（十四）WebService-学习笔记","date":"2017-08-21T14:46:00.000Z","path":"2017/08/21/Java-微服务实践-Spring-Boot-系列（十四）WebService-学习笔记/","text":"写在前面的话，之前曾在项目中使用过Webservices，记得当时使用过Apache的CXF，Apache CXF = Celtix + XFire。 随着RESTful服务的越来越流行，渐渐地WebService技术已经渐渐被人们所淘汰。下面主要为了技术的温习，跟上小马哥一起再次复习下那些年我们使用过的WebService。 Web Services 定义：又称之为 Web Service，是一种设计通过网络来支持相互协作的机器间交互的软件系统。它拥有被机器可处理的格式所描述的接口（如：WSDL），规定使用 SOAP消息的方式与其他系统交互，典型地以HTTP传输、XML序列化以及联合其他Web 相关标准。— W3C, Web Services Glossary 标准整合方式&emsp;XML（可扩展标记语言）&emsp;SOAP（对象访问）&emsp;WSDL（网络服务描述语言）&emsp;UDDI（通用描述、发现与集成服务） 什么是 SOAP？ SOAP 指简易对象访问协议SOAP 是一种通信协议SOAP 用于应用程序之间的通信SOAP 是一种用于发送消息的格式SOAP 被设计用来通过因特网进行通信SOAP 独立于平台SOAP 独立于语言SOAP 基于 XMLSOAP 很简单并可扩展SOAP 允许您绕过防火墙SOAP 将被作为 W3C 标准来发展 SOAP 数据封装 SOAP 消息：在SOAP节点之间表达交换的信息SOAP 信封：鉴定SOAP 消息的XML封装元素SOAP 头块：SOAP 头的基本单元SOAP 头：一个或多个SOAP 头块集合SOAP 主体：交给接收端包含消息的主体SOAP 故障：SOAP 节点故障时处理消息 什么是WSDL? WSDL 指网络服务描述语言WSDL 使用 XML 编写WSDL 是一种 XML 文档WSDL 用于描述网络服务WSDL 也可用于定位网络服务WSDL 还不是 W3C 标准 什么是 UDDI？ UDDI 是一个独立于平台的框架，用于通过使用 Internet 来描述服务，发现企业，并对企业服务进行集成。UDDI 指的是通用描述、发现与集成服务UDDI 是一种用于存储有关 web services 的信息的目录。UDDI 是一种由 WSDL 描述的 web services 界面的目录。UDDI 经由 SOAP 进行通信UDDI 被构建入了微软的 .NET 平台 以上概念定义解释来自w3cschool 其中需要注意的有使用Java6以后自带的xjc工具根据xsd生成webservices相关实体代码命令：1xjc -d src/main/java -p com.example.springbootwebservices.domain src/main/resources/META-INF/schemas/user.xsd -d表示指定java包路径的相对目录 具体SpringBoot中使用webservices案例请参考：https://github.com/mercyblitz/segmentfault-lessons/tree/master/spring-boot/lesson-14/spring-boot-lesson-14","tags":[{"name":"springboot","slug":"springboot","permalink":"http://baiwenhui.com/tags/springboot/"},{"name":"webservices","slug":"webservices","permalink":"http://baiwenhui.com/tags/webservices/"}]},{"title":"HTTP状态码图示","date":"2017-08-13T08:00:00.000Z","path":"2017/08/13/HTTP状态码图示/","text":"这里总结下我们日常开发中常用的HTTP状态码，分享一个老外对HTTP状态码形象化用图片表示的网站：https://http.cat/ 总结如下： 表示服务器已经接收到了请求头，并且客户端应该继续发送请求体。表示请求方已经要求服务器切换协议，并且服务器已经接受并会进行处理。HTTP 请求成功的标准应答。实际的应答内容由请求使用的方法来决定。请求已经被接受，并且请求所对应的资源已经被创建。请求已被接受，尚未完成处理，也有可能会被拒绝。在成功处理请求后服务器并没有返回任何实体内容。依照子请求的数量的不同，消息体包含不同的响应代码。表示被请求的资源可以提供多种选项让客户端进行选择该请求应当被定向到给定的URI（统一资源定位符）这是一个工业实践和标准相互矛盾的例子。一些Web应用和框架会使用302状态码对应当前请求的响应可以使用GET方法从另一个URI获取表示资源自上次请求以来没有被改变。（译注：被请求的资源必须通过指定的代理才能被访问） 大多数HTTP客户端不会正确响应这个状态码，主要是出于安全性的原因在这种情况下，请求会从另外的URI响应但是未来的请求仍会使用原始的URI因为错误的语法，请求不能完成当需要授权，但授权失败或还没有授权时返回的状态码该状态码是为了将来可能的需求而预留的。这个代码通常不使用，但是其最初的意图是可以被某种电子货币所使用。请求有效，但是服务器拒绝响应它。请求的资源不能找到，但是将来也许可用。请求某资源时使用的请求方法不能被该资源所支持。被请求资源能够产生的内容不满足请求头中指定的类型。服务器等待请求超时因为请求中存在冲突导致请求无法被处理被请求的资源已不可用，同时后续也不再可用。请求所对应的资源需要指明长度，但请求中并没有包含长度。其请求数据实体过大，超过服务器处理能力。URI过长，服务器不能处理客户端请求部分文件，但是服务器并不能提供这个范围值。服务器不能满足请求头重指定的要求。在实际HTTP服务器中不会实现该状态码请求格式正确但是因为存在语意错误无法响应。当前资源被上锁因为之前的请求失败而导致了本次请求失败在WebDav Advanced Collections 草案中定义客户端应该切换到不同的协议用户在指定时间内发送的请求过多。因为请求中的单个域过大、或者全部域全加起来过大。在Nginx记录中使用，表示服务器没有向客户端返回信息并且已经关闭了连接微软所扩展的一个状态码当没有其他更加确切的信息可以给出时，给出的一个一般性错误信息。作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应服务器当前不可用。请求的透明内容协商导致循环引用服务器无法存储完成请求所必须的内容。服务器在处理请求时发现一个无限循环尽管很多服务器使用该协议，但其并没有在任何RFC中说明这个状态码没有在任何RFC中说明，但微软公司在用。","tags":[{"name":"http","slug":"http","permalink":"http://baiwenhui.com/tags/http/"}]},{"title":"Groovy入门-变量与变量类型","date":"2017-08-13T06:34:00.000Z","path":"2017/08/13/Groovy入门-变量与变量类型/","text":"Groovy的变量与变量类型变量与常量的定义，维基百科对其定义如下变量：变量通常是可被修改的，即可以用来表示可变的状态。常量：指一个数值固定不变的常量，例如圆周率、自然对数的底。与之相反的是变量。 动态变量与静态变量动态变量：动态变量在程序执行过程中建立，随函数的调用需要动态的分配存储空间，调用结束释放所占用存储空间。静态变量：静态变量（Static Variable）在计算机编程领域指在程序执行前系统就为之静态分配（也即在运行时中不再改变分配情况）存储空间的一类变量。 Groovy中的变量类型Groovy中可以使用的变量类型有数字（Number）类型、字符串（String）类型、布尔（Boolean）类型以及引用（Reference）类型。 1.数字（Number）类型：包括整数类型和浮点数类型。 其中，整数包含正数、负数和零，都是Integer类的实例，比如1、-1和0都属于整数类型。 浮点数包含小数部分，都是BigDecimal类的实例，比如1.11、-3.11都属于常见的浮点数类型。在数字字面值加上可显示指定变量的类型，整数Long型（Long）、整数BigInteger型（BigInteger）、浮点型Float（Float）、浮点数Double（Double）。 2.字符串（String）类型：通过使用引号将文本值组织起来，如’Hello’、”Hello”、”””Hello”””，其中使用单引号（‘）、双引号(“”)、三双引号（”””）都是允许的。 3.布尔（Boolean）类型： 包含true和false。如def judge = true,def 在groovy中表示任意类型，在程序运行期动态推到其最终类型。 4.引用（Reference）类型：用于表示指向一个对象。比如：def user = new User(name:”张三”)。其中user表示的就是User对象的实例。 Groovy中变量的声明和使用 声明的变量名称通常被称为标识符。在Groovy中，标识符的命名规则如下： 标识符必须由字母和数字组成，大小写敏感，标识符的首字符必须是字母。下划线(_)允许出现在标识符中，以字母看待。标识符绝对不允许是 Groovy关键词。声明变量时需要引入变量名称，可以为变量指定初始值，也可以确定变量能被引用的作用域或者作用范围。当在程序中首次使用某个变量时，需要使用Groovy关键def关键字声明，不能在同一个作用域内声明两次相同的变量名。 示例：1234567891011121314151617181920212223242526272829303132333435363738394041/** * Groovy中对不同类型变量的定义和使用 * @author strongant * Contact me at &lt;a href=&quot;mailto:strongant1994@gmail.com&quot;&gt;strongant1994@gmail.com&lt;/a&gt; * @see * @since 2017/8/13 */class DefineUseVariable &#123; public static void main(String[] args) &#123; // 声明一个值为admin，类型为String的变量 def name = &apos;admin&apos; // 声明一个值为10的数字，类型为Integer def age = 10 // 声明一个值为20.0的数字，类型为BigDecimal def money = 20.0 // 声明一个值为true的布尔变量，类型为Boolean def isMale = true // 再次声明一个值为admin，类型为String的变量，下面代码将运行错误。 //def name = &quot;Bob&quot; // 输出变量的值和类型。 //注意，在输出的时候，如果要使用&apos;$&apos;符号进行输出变量，则字符串必须使用双引号的三双引号的情况下，才可以正常输出变量值。 // 如果是单引号，则不会输出变量值，原样输出 println &quot;name is $&#123;name&#125;. I&apos;m $&#123;age&#125; years old. I hava $&#123;money&#125; dollars.&quot; println &quot;name type: $&#123;name.class&#125;&quot; println &quot;age type: $&#123;age.class&#125;&quot; println &quot;money type: $&#123;money.class&#125;&quot; println &quot;isMale type: $&#123;isMale.class&#125;&quot; // 声明一个值为10.0的浮点型的变量，类型为Float def floatTypeVariable = 10.0F println &quot;floatTypeVariable type: $&#123;floatTypeVariable.class&#125;&quot; // 声明一个值为10.0的浮点型的变量，类型为Double def doubleTypeVariable = 10.0D println &quot;doubleTypeVariable type: $&#123;doubleTypeVariable.class&#125;&quot; // 声明一个值为10000的长整型的变量，类型为Long def longTypeVariable = 10000L println &quot;longTypeVariable type: $&#123;longTypeVariable.class&#125;&quot; // 声明一个值为10000的长整型的变量，类型为大长整型BigInteger def bigIntegerTypeVariable = 10000G println &quot;bigIntegerTypeVariable type: $&#123;bigIntegerTypeVariable.class&#125;&quot; &#125;&#125; 示例的代码也可以在此地址找到：https://gist.github.com/strongant/22c489f5a51f416d1bf3e97d86f031dd Groovy变量自动转换和强制转换示意图 Groovy中关键字abstract case do finally instanceof package strictfp throws with any catch double float int private super transient as assert char class else enum for if interface long protected public switch synchronized true try boolean continue extends implements native return this void break def false import new short threadsafe volatile byte default final in null static throw while","tags":[{"name":"groovy","slug":"groovy","permalink":"http://baiwenhui.com/tags/groovy/"}]},{"title":"Groovy入门-安装","date":"2017-08-13T03:03:00.000Z","path":"2017/08/13/Groovy入门/","text":"使用groovy开发差不多已经四个多月了，这里分享一些自己在groovy方面的一些总结。 介绍 Groovy 是一种新兴的运行于 Java™ 平台之上的编程语言 它提供与已有 Java 代码的无缝集成，并引入了一些强大的新特性，比如闭包和元编程 简单来讲，Groovy 就是在 21 世纪 Java 语言的的效果 Groovy是Java平台上脚本语言，抽象程度更高，可以更简单快速的开发，可以编写更少的代码 与Java语言无缝集成，可以称为“超级Java” 使用“类JAVA语法”，Java程序员可以快速过度 Groovy与Java二进制兼容，都生成字节码，所以可以与使用Java语言所编写的框架和组件完美集成，并且效率安全方面比其他脚本语言要高 Groovy对象就是Java对象，使用JDK相同的API 可以保护整个Java产业在Java上巨大的投资 在中小型项目中可以替代Java，在大型Java项目中可以嵌入Groovy应用 安装，使用官网推荐的安装方法首先安装SDKMAN! (一个软件开发工具包管理工具)1$ curl -s get.sdkman.io | bash 使其SDKMAN工具生效1$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot; 安装最新版本的Groovy: 1$ sdk install groovy 等待一会儿之后，显示安装完毕，此时我们可以使用此命令验证groovy是否安装成功 1$ groovy -version 安装2 在官网下载groovy sdk下载地址:https://akamai.bintray.com/9a/9a20d8868edbbc82a8edd03b6ae6f7dfbe406e42a468f2c44d5285493f679676?__gda__=exp=1466580235~hmac=4c1a4086a45aca9a522aac513d022d04f90eec437163110a69a441bf823143a2&amp;response-content-disposition=attachment%3Bfilename%3D%22apache-groovy-sdk-2.4.7.zip%22&amp;response-content-type=application%2Fx-www-form-urlencoded 进行解压： 1$ unzip apache-groovy-sdk-2.4.7.zip 配置到全局变量或者用户所在的变量环境 12345sudo vi /etc/profile//添加groovy解压目录所在的位置//我当前安装目录为：/home/devbwh/groovy-2.4.7，在/etc/profile文件末尾添加一下配置：export GROOVY_HOME=/home/devbwh/groovy-2.4.7export PATH=GROOVY_HOME/bin:$PATH 使其生效 1source /etc/profile 安装3(Mac安装)1brew install groovy","tags":[{"name":"groovy","slug":"groovy","permalink":"http://baiwenhui.com/tags/groovy/"}]},{"title":"跟小马哥学习SpringBoot","date":"2017-08-12T06:36:23.000Z","path":"2017/08/12/跟小马哥学习SpringBoot/","text":"这里推荐一个不错的Spring Boot系列讲座，讲师简介如下： 小马哥，阿里巴巴技术专家，从事十余年Java EE 开发，国内微服务技术讲师。目前主要负责微服务技术推广、架构设计、基础设施、迁移等。重点关注云计算、微服务以及软件架构等领域。获得过 SUN Java（SCJP、SCWCD、SCBCD）以及 Oracle OCA 等的认证。 讲座大纲 Java 微服务实践 - Spring Boot 系列（一）初体验 Java 微服务实践 - Spring Boot 系列（二） Web篇（上） Java 微服务实践 - Spring Boot 系列（三）Web篇（中） Java 微服务实践 - Spring Boot 系列（四）Web篇（下） Java 微服务实践 - Spring Boot 系列（五）嵌入式Web容器 Java 微服务实践 - Spring Boot 系列（六）数据库 JDBC Java 微服务实践 - Spring Boot 系列（七）MyBatis Java 微服务实践 - Spring Boot 系列（八）JPA Java 微服务实践 - Spring Boot 系列（九）NoSQL Java 微服务实践 - Spring Boot 系列（十）缓存 Java 微服务实践 - Spring Boot 系列（十一）消息 Java 微服务实践 - Spring Boot 系列（十二）验证 Java 微服务实践 - Spring Boot 系列（十三）WebSocket Java 微服务实践- Spring Boot 系列（十四）WebService Java 微服务实践 - Spring Boot 系列（十五）安全 Java 微服务实践 - Spring Boot 系列（十六）日志 Java 微服务实践 - Spring Boot 系列（十七）监管 Java 微服务实践 - Spring Boot 系列（十八）配置 Java 微服务实践 - Spring Boot 系列（十九）测试 Java 微服务实践 - Spring Boot 系列（二十）自定义启动器 原文链接：https://segmentfault.com/u/mercyblitz/lives?type=started本文作者：小马哥","tags":[]},{"title":"Mac上传图片至图床神器","date":"2017-08-12T03:47:00.000Z","path":"2017/08/12/Mac上传图片至图床神器/","text":"推荐一款Mac上上传图片到图床的神器：IPic具体的下载和使用方法可以戳这儿https://toolinbox.net/iPic/","tags":[{"name":"图床","slug":"图床","permalink":"http://baiwenhui.com/tags/图床/"},{"name":"图片","slug":"图片","permalink":"http://baiwenhui.com/tags/图片/"},{"name":"工具","slug":"工具","permalink":"http://baiwenhui.com/tags/工具/"}]},{"title":"Git常用命令记录","date":"2017-08-11T15:13:00.000Z","path":"2017/08/11/Git常用命令记录/","text":"Git常用命令记录","tags":[{"name":"git","slug":"git","permalink":"http://baiwenhui.com/tags/git/"}]},{"title":"使用angular中的service和filter编写组件树","date":"2017-08-05T08:49:00.000Z","path":"2017/08/05/使用angular中的service和filter编写组件树/","text":"学习《AngularJS深度剖析与实践》总结 在我们平时的开发中，需要对某些数据进行以树的形式进行展现，比如：权限角色、菜单、嵌套评论等。这个时候我们需要使用angular进行对数据抽象，构造我们自己的组件树： 例子：我们就拿主题树作为一个例子，然后一步一步去优雅的实现它: 首先我们准备好angular的库文件，建立好相应的目录及文件，按照angular遵循的风格：约定优于配置。首先我们创建一个用于展示的目录，theme-tree1mkdir theme-tree &amp;&amp; cd $_ 2.创建需要展示的html页面文件:1touch index.html 3.创建存放项目js文件的目录:1mkdir js 4.创建存放angular项目的controller目录、service目录和filter目录:1mkdir controller &amp;&amp; mkdir service &amp;&amp; mkdir filter 5.创建angular项目的入口文件，app.js1cd js &amp;&amp; touch app.js 6.目前先不考虑UI效果部分，主要以实现功能为主，我们使用bower来安装和管理相应的js第三方库文件，如果没有安装bower工具，可以借助npm进行安装-npm install -g bower ,在我们创建的theme-tree目录下，键入如下命令安装angular库的依赖：1bower install angular --save 以上命令实行完毕后我们的目录结构如下： 7.接下来我们开始编辑js/app.js入口文件：1angular.module(&apos;myApp&apos;, []); 8.接下来我们开始编写控制器文件js/controller/index.client.controller.js:1234567891011121314151617181920212223242526272829303132333435363738394041angular.module(&apos;myApp&apos;).controller(&quot;ThreedTreeCtrl&quot;,function ThreedTreeCtrl(tree) &#123; var vm = this; vm.items = [&#123; id: 1, title: &quot;Java&quot;, poster: &quot;Messi&quot;, dateCreated: &quot;2012-02-19T00:00:00&quot;, items: [&#123; id: 11, title: &apos;Spring&apos;, poster: &apos;John&apos;, dateCreated: &quot;2012-02-19T00:00:00&quot;, items: [ &#123; id: 111, title: &apos;AOP&apos;, poster: &apos;Mike&apos;, dateCreated: &quot;2016-02-19T00:00:00&quot;, items: [ &#123; id: 1111, title: &apos;IOC&apos;, poster: &apos;Jack&apos;] &#125; ] &#125;, &#123; id: 2, title: &quot;SpringBoot&quot;, poster: &quot;Lucy&quot;, dateCreated: &quot;2011-02-19T00:00:00&quot; &#125; ] &#125;, &#123; id: 2, title: &quot;JavaScript&quot;, poster: &quot;Jack&quot;, dateCreated: &quot;2012-02-19T00:00:00&quot;, &#125; ];&#125;); 以上内容很简单，构建了一个ThreedTreeCtrl控制器，里面嵌套了一些随意的数据，主要是为了模拟父子关系； 9.接下来我们编辑js/service/index.client.service.js文件，用于对数据进行附加相应的行为。思考一下，当我们有了这样一组数据后，我们要为它添加什么方法和属性，首先应该添加父节点是否折叠，此属性主要是为了在界面显示的时候展开或折叠子节点数据。当展开的时候我们使用“-”表示，折叠的时候我们使用”+”表示，当折叠时单击节点应该展开子节点，当展开的时候，单击子节点应该折叠父节点；将新增的属性和方法为了减小和原始数据冲突，并且这些数据通过$http或者$resource提交给服务器，它们所调用的angular.toJso()函数会忽略所有以$开头的属性，这样我们扩展的属性就不会被提交到服务端了。还有一个方便的是，当我们看到数据上有”$”开头的属性就是扩展的属性。接下来我们实现它：123456789101112131415161718192021222324252627282930angular.module(&apos;myApp&apos;).service(&apos;tree&apos;,function Tree()&#123; var self = this; //为每一项节点添加属性和方法 var enhanceItem = function(item,childrenName)&#123; item.$hasChildren = function()&#123; var subItems = this[childrenName]; return angular.isArray(subItems) &amp;&amp; subItems.length; &#125;; item.$foldToggle = function()&#123; this.$folded = !this.$folded; &#125;; item.$isFolded = function()&#123; return this.$folded; &#125;; &#125;; //对传进来的数据进行强化 this.enhance = function(items,childrenName)&#123; if(angular.isUndefined(childrenName))&#123; childrenName = &quot;items&quot;; &#125; angular.forEach(items,function(item)&#123; enhanceItem(item,childrenName); //如果有子节点则递归处理 self.enhance(item[childrenName],childrenName); &#125;); console.log(items); return items; &#125;;&#125;); 10.这样我们完成了对数据进行强化，此时我们如果直接在controller调用service的enhance 方法，将服务端返回的json数据进行加强，为他们添加的相应的属性和方法，然后在页面进行展示调用就可以了，但是这样感觉比较脏，不干净，我们不在contrller直接调用service里面的enhance 方法，我们可以创建一个过滤器来对数据进行添加过滤的功能，接下来我们开始编辑filter/index.client.filter.js: 123456angular.module(&apos;myApp&apos;).filter(&apos;tree&apos;,function(tree)&#123; return function(items,childrenName)&#123; tree.enhance(items,childrenName); return items; &#125;;&#125;); 11.接下来编写html文件，开始对主题树进行展现并且引入相关文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;ThreedTreeCtrl as vm&quot;&gt; &lt;ul ng-if=&quot;vm.items&quot;&gt; &lt;li ng-repeat=&quot;item1 in vm.items | tree&quot;&gt; &lt;div ng-click=&quot;item1.$foldToggle()&quot;&gt; &lt;span ng-if=&quot;item1.$hasChildren()&quot;&gt; &lt;span ng-if=&quot;!item1.$isFolded()&quot;&gt;-&lt;/span&gt; &lt;span ng-if=&quot;item1.$isFolded()&quot;&gt;+&lt;/span&gt; &lt;/span&gt; &#123;&#123; item1.title &#125;&#125; &lt;/div&gt; &lt;ul ng-if=&quot;item1.$hasChildren() &amp;&amp; !item1.$isFolded()&quot;&gt; &lt;li ng-repeat=&quot;item2 in item1.items&quot;&gt; &lt;div ng-click=&quot;item2.$foldToggle()&quot;&gt; &lt;span ng-if=&quot;item2.$hasChildren()&quot;&gt; &lt;span ng-if=&quot;!item2.$isFolded()&quot;&gt;-&lt;/span&gt; &lt;span ng-if=&quot;item2.$isFolded()&quot;&gt;+&lt;/span&gt; &lt;/span&gt; &#123;&#123; item2.title &#125;&#125; &lt;/div&gt; &lt;ul ng-if=&quot;item2.$hasChildren() &amp;&amp; !item2.$isFolded()&quot;&gt; &lt;li ng-repeat=&quot;item3 in item2.items&quot;&gt; &#123;&#123; item3.title &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;bower_components/angular/angular.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/controller/index.client.controller.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/service/index.client.service.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/filters/index.client.filter.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 此时我们便完成了对主题树功能的实现，在index.html文件中，我们只展示了两层嵌套关系以作为示例，根据自己的业务场景进行扩展。以上实现还不够优雅，等待以后需要将主题递归树封装为指令，最后附上github地址:https://github.com/strongant/angularjs源码位于此仓库下的angular-tree目录，欢迎提出issue。","tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://baiwenhui.com/tags/angularjs/"}]},{"title":"监听chrome extension popup页面消失","date":"2017-08-05T08:46:00.000Z","path":"2017/08/05/监听chrome-extension-popup页面消失/","text":"需求 当用户不小心点击了鼠标或者离开了扩展的popup页面，此时需要对一些数据进行清空或者删除一些不必要的数据. 遇到的问题 然而chrome 扩展官方并没有对popup或者browserAction提供相关页面消失时的监听事件 解决办法 通过不断的查找资料和查阅chrome扩展开发文档，我们可以使用消息通信连接的方式解决了这个问题具体步骤: 首先在你需要监听页面消失事件的js文件中与background建立连接，相关代码: 12//这里主要是为了与background建立连接，当页面关闭的时候连接就会断开，此时background中你注册的连接关闭函数此时会执行，因为background环境一直存在，除非你关闭了电脑 var port = chrome.runtime.connect(); 在background环境注册断开连接时需要处理的方法，相关代码: 123456 chrome.runtime.onConnect.addListener(function (externalPort) &#123; externalPort.onDisconnect.addListener(function() &#123; var ignoreError = chrome.runtime.lastError; console.log(&quot;onDisconnect&quot;); &#125;); &#125;); 总结 通过以上的方式便实现了类似对popup页面消失时做一些事情的需求。感谢StackOverFlow，神一样的解决问题社区，致敬！","tags":[{"name":"chrome扩展","slug":"chrome扩展","permalink":"http://baiwenhui.com/tags/chrome扩展/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://baiwenhui.com/tags/JavaScript/"}]},{"title":"上班路上的琐事","date":"2017-08-05T06:59:00.000Z","path":"2017/08/05/生活感慨/","text":"事件起因 骑着电动车上班也有4个月了，总体感觉还是很不错的！由之前坐地铁上班花费1个半小时减少到现在的半个小时，还是很不错的一笔投资！其实后悔电瓶车买的有点迟了，如果早点买的话起码可以在出行方面带来很多方便，虽然现在有很多的共享单车可以骑，但是对于上海这么大的地方和上班距离遥远的情况，对于骑自行车来上班肯定是来不及的，速度也跟不上，根本无法满足自己的需求！可就在昨天下午2017年8月5号18点20分左右，当我插上电动车钥匙，死活就是启动不了电瓶车，而且电瓶车很明显没有一丁点儿电了，大灯不亮，喇叭不响，心里一下难过了，到底什么鬼导致这个问题的发生呢？然后想了想，我靠，中午的时候貌似下很大的雨，不会是雨漏到电瓶或者控制器里面，导致短路了吧？这个只是当时的猜测，后面接着开始用百度进行搜索一下，看网上有没有类似的网友遇到此问题，网上扫了一圈，基本上都说是可能是电瓶进水了，把电瓶晾干就可以骑了，其实当时想给卖车的师傅打电话的，又相信了网上的答案，于是便将车放到车棚里面坐地铁回家了，晚上可是要看《战狼2》的，不然时间来不及了，于是便放下电动车，匆忙往电影院赶！ 事件经过 晚上看完电影，天气湿热湿热，难受至极，晚上浑浑噩噩的睡了一晚上。大清早9点多就起来了，起来便开始准备去公司看看电瓶车是不是像网上说的那样，等到电瓶晾干了，就可以骑了！于是乎开始骑单车、等公交、坐公交、等地铁、坐地铁，从出发到到达公司，大概花费了我2个小时，在这里我不得不吐槽交通问题，其实住的地方离公司只有20公里，有一次我起迟了害怕迟到，就打了个车到公司，花了40块钱。但是花费时间让我很惊讶，只用了10分钟，我就纳闷了，为什么这么快呢？原来是因为坐地铁比较绕，而且也没有直达的公交，如果坐公交的话也是特别绕，所以就浪费了不应该浪费的2个小时时间。这一点可能是因为个人住的地方偏远原因吧，不过我想很多人应该也有类似的愤怒，明明不是很远，却要绕很多路花很多时间才能到目的地。抱怨没用，只能自己想办法解决！到了公司之后去找到电瓶车，幸亏公司的安保措施做得不错，车子没有被偷，谢天谢地！当我插上钥匙，和昨天下午一个样，还是没有电，顿时想：糟糕，肯定是电瓶进水太严重，导致车子彻底没电了，这时候我想打电话找个修车师傅帮我看看，可卖车的地方离公司太远了，就想着要不要找个距离我比较近的修车师傅过来看看，又顾虑这是新车，如果让别人拆开修，人家不给我保修了怎么办，买下车骑了也没有多长时间，不划算！还是打电话问一下原卖车的师傅，我把情况给人家说了一下：昨天中午下了会大雨，车子没有用雨衣盖住，昨天下班后钥匙插上之后，启动不了，纯粹没电！然后又经验的师傅说了下：你检查一下座子下面那个开关是不是把电瓶的电源关闭了。于是我便按照他说的，打开后座，把开关切换了一些，然后用钥匙插上，发现奇迹产生了，电动车一切正常，心里窃喜，不用修了，感谢有经验的老司机！ 又出波折 由于又可以正常骑行了，不用挤地铁，一切恢复正常，心里比较窃喜，骑行的过程中一不小心就撞到了马路边的一个栏杆桩上面，这一撞直接把电瓶车的单撑撞断了，于是骑到卖车的地方花了40块钱焊接了一下，唉，这半天的时间又浪费过去了！无奈！ 事件总结 在平时用车的时候，应该特别小心，注意安全！最后分享一个CCTV7的对电动车电池修复技术的介绍视频，本人觉得讲解的很好，很细致！http://tv.cntv.cn/video/C10391/258219f0a78b491c452527b41bb3088c","tags":[{"name":"随笔","slug":"随笔","permalink":"http://baiwenhui.com/tags/随笔/"}]},{"title":"Grails中一个日期差引起的思考","date":"2017-08-02T14:02:00.000Z","path":"2017/08/02/Grails中一个日期差引起的思考/","text":"需求如下 对某表中的数据进行查询限制，当根据某个条件进行查询表记录时，如果该记录的查询时间与当前服务器时间相差大于一周，则允许查询操作，否则不允许重复查询操作。 编码根据当前需求进行编码，代码如下：1234567891011121314151617181920class ExampleController &#123; def test() &#123; ... def obj = XXX.findByName(&apos;xxx&apos;) def limitDays = 7 if(obj &amp;&amp; daysBetween(obj.queryTime,new Date())&lt;=7)&#123; render([code: 10101, msg: &quot;查询失败，7天内不允许重复查询&quot;, data: []] as grails.converters.JSON) return &#125; ... &#125; //TODO: 将此处判断移动至service或者util类 static def daysBetween(def startDate, def endDate) &#123; use(groovy.time.TimeCategory) &#123; def duration = endDate - startDate return duration.days &#125; &#125;&#125; 出现bug:本地测试程序可以正常执行，但是发现在生产环境下并没有正常执行 错误解决：以为是groovy.time.TimeCategory原生类有bug，将比较日期间隔天数的方法修改为如下: 1234//TODO: 将此处判断移动至service或者util类static boolean keep7Days(endDate)&#123; return (System.currentTimeMillis()-endDate.getTime())&lt;3600*1000*24*7&#125; 修改结果：问题依然存在。 进行分析： 当我们从某张表中根据某个条件查询一条记录，如果该条件对一个多条重复记录，那数据库将按照表中的记录插入顺序返回最初插入的一条记录。因此，当根据某条件进行匹配查询时，应该按照id降序排列后取得第一条即可。 解决办法：123...def obj = XXX.find(&quot;from XXX as b where b.xxx=:xxx order by b.id desc&quot;,[xxx:xxx])... 通过以上方式，我们便可以得到最后插入的记录，此时再使用时间差进行判断就不会出现匹配不正确问题。 总结当项目中遇到bug时应该找到问题的根源再进行解决。在测试的过程中数据应该保持和生产环境数据一致！ 彩蛋推荐两个不错的播客平台： 内核恐慌 比特新声","tags":[{"name":"grails","slug":"grails","permalink":"http://baiwenhui.com/tags/grails/"},{"name":"groovy","slug":"groovy","permalink":"http://baiwenhui.com/tags/groovy/"},{"name":"gorm","slug":"gorm","permalink":"http://baiwenhui.com/tags/gorm/"}]},{"title":"Mac通过brew安装redis","date":"2017-07-26T13:41:00.000Z","path":"2017/07/26/Mac通过brew安装redis/","text":"MacOS下通过brew安装redis安装redis:1brew install redis 安装后的地址为:/usr/local/Cellar/redis/3.2.9 链接redis的launch开机启动配置文件1ln -sfv /usr/local/opt/redis/*.plist ~/Library/LaunchAgents 使用launchctl启动redis，每次开机启动1launchctl load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 通过redis的配置文件进行启动1redis-server /usr/local/etc/redis.conf 停止开机启动redis1launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 安装后的redis默认配置文件地址：1/usr/local/etc/redis.conf 卸载redis12brew uninstall redisrm ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 获取redis的安装信息1brew info redis 测试redis是否启动1redis-cli ping 如果redis返回“PONG”，那么说明连接成功","tags":[{"name":"mac","slug":"mac","permalink":"http://baiwenhui.com/tags/mac/"},{"name":"redis","slug":"redis","permalink":"http://baiwenhui.com/tags/redis/"},{"name":"brew","slug":"brew","permalink":"http://baiwenhui.com/tags/brew/"}]},{"title":"Ubuntu安装Java8环境","date":"2017-07-26T13:32:00.000Z","path":"2017/07/26/Ubuntu安装Java8环境/","text":"Ubuntu 系统安装Java8 JDK1.添加ppa1sudo add-apt-repository ppa:webupd8team/java 2.更新系统1sudo apt-get update 3.开始安装1sudo apt-get install oracle-java8-installer -y 4.验证是否安装成功1java -version 5.安装脚本gist地址(执行脚本时记得回车继续，其中弹出确认安装提示选择是即可，脚本执行完毕后就已经成功安装Java8了，安装大约得等待一段时间，请耐心等待！):https://gist.github.com/strongant/740f58dd6f116a4ff4d156805340bb95","tags":[{"name":"jdk","slug":"jdk","permalink":"http://baiwenhui.com/tags/jdk/"},{"name":"java8","slug":"java8","permalink":"http://baiwenhui.com/tags/java8/"},{"name":"sh","slug":"sh","permalink":"http://baiwenhui.com/tags/sh/"}]},{"title":"终端录制神器-showterm","date":"2017-07-26T12:21:00.000Z","path":"2017/07/26/终端录制神器/","text":"使用showterm对终端脚本进行录制安装 如果是Mac用户，直接使用如下命令即可安装(默认情况下，Mac OS X 系统已经安装好 Ruby): 1gem install showterm 如果是Linux用户，可使用如下方式安装: 12curl showterm.io/showterm &gt; /usr/local/bin/showtermchmod +x /usr/local/bin/showterm 安装完毕之后便可以对终端进行录制了，录制后的结果是一个视频文件，并且为你自动生成一个可以公开访问的地址，非常方便； 验证是否安装成功： 1showterm -h 如果显示此工具使用方法，则说明安装成功！ 使用方法 打开终端，输入showterm，此时showterm会提示您正在进行脚本视频录制，如： 1showterm recording. (Exit shell when done.) 当你脚本录入完毕后，此时便可以使用exit命令结束本次录制。此时你会得到以下类似提示： 123showterm recording finished.Uploading...http://showterm.io/44c650714d8a45b265064 此时打开http://showterm.io/44c650714d8a45b265064 链接便可以对刚才的脚本操作进行显示！","tags":[{"name":"工具","slug":"工具","permalink":"http://baiwenhui.com/tags/工具/"},{"name":"终端","slug":"终端","permalink":"http://baiwenhui.com/tags/终端/"},{"name":"showterm","slug":"showterm","permalink":"http://baiwenhui.com/tags/showterm/"}]},{"title":"IDEA Mac下快捷键奇淫技巧","date":"2017-07-22T13:59:00.000Z","path":"2017/07/22/IDEA-Mac下快捷键奇淫技巧/","text":"为你的ide设置背景图片；只需要双击enter键，然后输入set back， 找到Set Background Image 选择你想要添加的背景图片即可。如果不需要设置图片，再次打开单击clear按钮即可清除。 若果你想展示自己点击的按钮快捷键，可以安装Presentation Assistant即可，安装完之后需要重启。 如果你想快速跳到某一个类的某一行，那么你可以使用Command+O,然后键入你想要跳转的类名称，然后输入冒号加行号； 如果你想看到你进入这个类中总共有哪些方法，你可以使用Command+7，此时便可以显示这个类中的所有方法； 如果你想找到某个类中的某个字段，你可以使用Command+Option+O,然后通过”/id”的方式，就可以找到所有包含id属性的类； 如果你想查看某个类中的变量或者方法在哪儿使用，直接使用Command+B即可； 如果你想查看某个变量的引用定义详情，则可以选中这个变量，然后使用Command+Y； 如果你想扩展左边项目结构窗口的大小，则可以使用Command+Shift+&gt;(右方向键)； 如果你想对编辑器某些窗口进行显示和隐藏，则可以双击Shift键，然后输入”#editor “,则可以对当前编辑器进行一些快速设置； 如果你想在idea中快速测试rest服务，则可以双击Shift然后输入test rest，找到最后一项打开rest test client便可以对服务进行测试调用； 如果你想双击Shift后，键入ws便可以打开test restful client tool，可以在keymap设置中输入test rest，找到Tools–Test Restful Webservice，然后选中右键选择Abbreviation设置ws，点击确定，然后双击Shift，输入ws，这时候第一项就是这个工具，此时便可以快速进入test restful client tool工具窗口； 如果你想对某个类进行全屏编辑，则可以使用Command+Shift+F12； 如果想快速打开项目结构视图，则可以使用Command+1； 如果你想对代码给别人展示或者review代码的时候，想放大某个类，则可以在view视图下选择：Enter Presenttion Mode即可，当然你也可以设置快捷键进行绑定，这个功能特别有用,比如我设置的是Command+Shift+S，这样当需要对某个文件进行展示时，直接按快捷键即可，在Presenttion Mode窗口中，我们可以使用Command+E显示最近浏览的文件，可以快速切换展示； 编辑器垂直分割和水平分割可以在菜单来Window下的edit tab中找到并绑定对应的快捷键； 当选择一行或者某个列时，使用option+上下方向键，不要使用鼠标勾选的方式； 如果你使用了两次以上剪贴操作，你想查看前几次的剪贴内容，则可以使用Commad+Shift+V,此时便可以找到前几次的剪贴记录； 如果你选择了某一行，想向上下选取，则使用option+上下方向键后，可以再使用shift+option+上下方向键； 当你需要对代码样式进行一些改变时，则可以选中代码片段 然后使用option+Enter； 如果你想在某个包下面建立一个类，你可以使用Command+上方向键激活导航bar，然后选择相应的目录，然后使用Command+N,新建你需要新建的类型即可，不要使用鼠标选择File新建，这样会影响效率； 如果不想在view中显示navbar，则可以设置navbar隐藏，方法：双击shift，输入nav，找到view navigation bar 选择off，然后使用Command+向上方向键便可以激活navbar； 如果你想使用BufferReader读取一个文件，此时你键入BufferReader bf = new的时候可以使用shift+option+space智能导入其派生类，由于 shift+option+space快键键可能会和输入法切换会有冲突，我设置成了shift+option+command+space； 如果你想在idea中引入包或者包裹异常，则可以使用option+Enter； 如果你想要对某个变量进行NPE验证，那么只需要使用这个变量名打”.”然后输入not，这时候选择相应的代码模板即可； 如果你想在代码的末尾添加分号，不要移动光标添加，直接使用shift+command+回车即可； 如果你想手写一个简单的JSON，可能需要使用转义字符进行转义双引号，此时你可以在字符串中使用option+回车选择Inject language reference选择JSON，然后再次使用option+回车键，选择Edit Json Fragement即可，此时你便可以在JSON 窗口中按照正常的方式编写JSON字符串了，IDE会自动帮你添加转义字符；同样的方式我们可以选择Regex，对正则进行编写，并且可以帮我们进行对正则校验，使用方法和JSON 输入的方式类似； 如果需要多行选中，则可以使用option+shift+鼠标点击 即可，或者可以使用control+G,然后继续选择你需要多行同时编辑的行，如果选择的行数多了，可以使用control+shift+g进行减少选中； 如果需要对选中的变量或者代码片段进行重构，则可以使用control+T； 对bool参数值进行转换，则可以对定义的bool变量选中然后使用control+T，输入invert，找到invert boolean，便可以对变量的值进行反转； 如果想对项目进行版本控制管理，使用Command+K或者使用Ctrl+V； 使用control+tab可以进行对不同的文件进行选择显示打开； 如果你想查看你目前使用快捷键的情况，则可以在idea的help菜单找到Poductivity Guide查看；注意：以上快捷键主要是Mac系统下的操作，如果你使用的是非Mac系统，那么你只需要安装Presentation Assistant便可以显示Linux和Windows上的快捷键如果想深入学习，可以参考该视频链接：https://www.youtube.com/watch?v=M2eL5YuqecQ&amp;list=PLQ176FUIyIUYUuSwE--flZWw2hfI21SjF&amp;index=2","tags":[{"name":"IDEA,Mac快捷键","slug":"IDEA-Mac快捷键","permalink":"http://baiwenhui.com/tags/IDEA-Mac快捷键/"}]},{"title":"使用springdata操作es出错org.elasticsearch.client.transport.NoNodeAvailableException","date":"2017-07-21T01:48:10.000Z","path":"2017/07/21/使用springdata操作es出错org-elasticsearch-client-transport-NoNodeAvailableException/","text":"之前的项目中使用的是http-client操作es，比较轻量级。目前为了学习下springdata，使用Java API 的方式来操作ES，但是在引入SpringData的es模块依赖后，操作es并未成功，出现以下错误：1org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [&#123;#transport#-1&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;] 注意：如果你下载elasticsearch的压缩包安装的话，可能不会出现该问题！因为es默认的配置文件cluster.name是elasticsearch。但是奇葩的是使用brew安装es之后，默认的elasticsearch.yml的配置项成了这样：cluster.name: elasticsearch_bwh，就是这个原因导致了这个问题的产生，项目启动后控制台一直抛这个错：1transport#-1&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125; not part of the cluster Cluster [Assassin], ignoring... 当执行添加操作时，提示：1org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [&#123;#transport#-1&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;] 最后需要注意的是，如果你修改了es默认的集群名称，则需要在src/main/resources/application.properties配置文件中进行指定： spring.data.elasticsearch.clusterName=elasticsearch_bwh通过源码org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchProperties可以看到，默认的clusterName为elasticsearch。 希望可以帮助遇到此类问题的同学。","tags":[{"name":"SpringData","slug":"SpringData","permalink":"http://baiwenhui.com/tags/SpringData/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://baiwenhui.com/tags/Elasticsearch/"}]},{"title":"hexo将多说替换为畅言","date":"2017-05-30T02:46:11.000Z","path":"2017/05/30/hexo将多说替换为畅言/","text":"由于多说团队在2017年6月1号停止了对多说的运营，因此需要将博客中使用的多说替换为畅言。 具体替换办法如下： 如果你没有畅言的账号，则首先去畅言的官网进行注册账号：畅言网址: http://changyan.kuaizhan.com/ 如果你已经注册过畅言的账号了，那么请直接登录即可； 注册登录成功之后，点击进入后台，如图,可以看到已经有APP ID和APP KEY，这两个字符串，等会在配置的时候需要： 由于我使用的是hexo的Yilia主题，这里以Yilia主题为主，进行下面的配置，其他主题类似。在畅言后台找到 安装畅言 点击展开之后，点击 通用代码安装 ，然后点击右边的复制代码，如图： 然后编辑你hexo目录下的themes/yilia/layout/_partial/post/duoshuo.ejs文件，将duoshuo.ejs中原来的内容全部删除，使用刚才拷贝的代码替换，替换后的样例如下： 12345678910&lt;!-- 畅言评论框 start --&gt;&lt;div id=&quot;SOHUCS&quot; sid=&quot;&lt;%=title %&gt;&quot; style=&quot;padding: 0px 30px 0px 46px;&quot;&gt;&lt;/div&gt;&lt;!-- 畅言评论框 end --&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function()&#123; var appid = &apos;你的appid&apos;; var conf = &apos;你的app key&apos;; var width = window.innerWidth || document.documentElement.clientWidth; if (width &lt; 960) &#123; window.document.write(&apos;&lt;script id=&quot;changyan_mobile_js&quot; charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=&apos; + appid + &apos;&amp;conf=&apos; + conf + &apos;&quot;&gt;&lt;\\/script&gt;&apos;); &#125; else &#123; var loadJs=function(d,a)&#123;var c=document.getElementsByTagName(&quot;head&quot;)[0]||document.head||document.documentElement;var b=document.createElement(&quot;script&quot;);b.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);b.setAttribute(&quot;charset&quot;,&quot;UTF-8&quot;);b.setAttribute(&quot;src&quot;,d);if(typeof a===&quot;function&quot;)&#123;if(window.attachEvent)&#123;b.onreadystatechange=function()&#123;var e=b.readyState;if(e===&quot;loaded&quot;||e===&quot;complete&quot;)&#123;b.onreadystatechange=null;a()&#125;&#125;&#125;else&#123;b.onload=a&#125;&#125;c.appendChild(b)&#125;;loadJs(&quot;https://changyan.sohu.com/upload/changyan.js&quot;,function()&#123;window.changyan.api.config(&#123;appid:appid,conf:conf&#125;)&#125;); &#125; &#125;)(); &lt;/script&gt; 然后就可以使用畅言了 由于我的域名已经备案，没有遇到网上说的不能正常加载畅言的方式，如果你的域名没有备案，具体Hacker方法，请参考：http://ev1l.cn/2017/05/13/changyancrack/ 注意： 如果你在配置中还有其他问题，欢迎打赏提问，我收到之后会快速帮你解决！","tags":[{"name":"Tools","slug":"Tools","permalink":"http://baiwenhui.com/tags/Tools/"}]},{"title":"递归的执行原理浅析","date":"2017-05-29T15:48:17.000Z","path":"2017/05/29/递归原理解析/","text":"首先使用递归输出经典的阶乘，描述如下： 1! =1 2! = 2 3! = 6… 接下来使用常规的递归方式实现（Java），则可以得到以下程序：1234567891011121314/** * Java普通递归实现阶乘 * * @param n 传递的大于0的正整数 * @return 该数字的阶乘 如：传递3 则计算 1 * 2 * 3 = 6 * 递归的核心思想自我理解： 先入栈计算直到递归终止 然后出栈 对每个栈中的值进行计算 最后得到结果 */ public static int factorial(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125; &#125; 递归调用示意图此递归的计算原理主要是先申请栈幁1到栈幁n，直到找到递归终止的条件，然后开始汇总结果，最后出栈，返回结果，这种递归算法方式有一个弊端，就是在计算的过程中当n很大的情况下会出现栈溢出的错误（java.lang.StackOverflowError），可以使用尾递归的方式进行优化，比如：1234567891011121314151617181920/** * 使用尾递归进行计算阶乘 * * @param n 需要计算的n的阶乘 * @param result 返回n的阶乘结果 如： 传递3 则计算 1 * 2 *3 = 6 * 计算过程如下： tailFactorial(3,1) * = tailFactorial(2,3*1) * = tailFactorial(1,2*3*1) * = tailFactorial(1,6) * = 6 * 揭秘：只使用一个栈幁就可以搞定计算 * @return 返回n的阶乘 */ public static int tailFactorial(int n, int result) &#123; if (n == 1) &#123; return result; &#125; else &#123; return tailFactorial(n - 1, n * result); &#125; &#125; 计算a,b（a,b为非负整数）的最大公约数？此题目可以使用欧几里得算法进行解答，实现代码如下：1234567891011121314/** * 欧几里得算法计算两个数的最大公约数 * @param p 需要计算的数a * @param q 需要计算的数b * @return 返回a，b的最大公约数 a,b 是大于0 的正整数 * 算法描述： 计算两个非负整数的最大公约数： 若q是0，则最大公约数为p。否则，将p除以q得到余数r，p和q的最大公约数则为q和r的最大公约数 */ public static int greatestCommonDivisors(int p , int q)&#123; if(q==0)&#123; return p; &#125; int r = p % q; return greatestCommonDivisors(q,r); &#125; 最后我们开始使用递归遍历某个目录下的所有子目录和文件进行加深理解和运用：123456789101112131415161718192021222324public static void printDirectoriesAndFilesByPath(String path) &#123; try &#123; File file = new File(path); if (file.exists()) &#123; File[] files = file.listFiles(); for (File f : files) &#123; if (f.isDirectory() &amp;&amp; f.listFiles().length &gt;= 0) &#123; if (f.isDirectory()) &#123; String directory = f.getAbsolutePath(); System.out.println(\"-------目录名称:\" + f.getAbsolutePath()); printDirectoriesAndFilesByPath(directory); &#125; &#125; else &#123; System.out.println(\"-------目录名称:\"+f.getParent()+\"---&gt;文件名称：\" + f.getAbsolutePath()); &#125; &#125; &#125; else &#123; System.out.println(\"对不起，文件路径不存在\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;","tags":[{"name":"DataStructureAndAlgorithm","slug":"DataStructureAndAlgorithm","permalink":"http://baiwenhui.com/tags/DataStructureAndAlgorithm/"}]},{"title":"SpringBoot学习一","date":"2017-03-12T15:42:17.000Z","path":"2017/03/12/SpringBoot学习一/","text":"SpringBoot Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 遵循建立生产就绪Spring应用程序的观点。SpringBoot支持约定优于配置的惯例，旨在让您尽快启动和运行。 Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. SpringBoot可以轻松的创建单独的，生产级的基于Spring的应用，您可以“直接运行”。我们为Spring平台和第三方库提供了开箱即用的设置，这样你就可以有条不斋的开始。大多数的SpringBoot程序只需要很少的Spring配置。 Features Create stand-alone Spring applications Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) Provide opinionated ‘starter’ POMs to simplify your Maven configuration Automatically configure Spring whenever possible Provide production-ready features such as metrics, health checks and externalized configuration Absolutely no code generation and no requirement for XML configuration 功能 创建标准独立的Spring应用程序 直接嵌入Tomcat、Jetty或者Undertow（不需要部署WAR文件） 提供建议的‘starter’POM模板以简化您的Maven配置 每当可能时自动配置Spring 提供生产就绪的功能，如指标，运行状况检查和外部化配置 绝对没有代码生成和不需要XML配置 The reference guide includes detailed descriptions of all the features, plus an extensive howto for common use cases.该参考指南包含所有功能的详细说明，以及广泛的如何使用共同使用情况。 Quick StartIf you are Java developer you can use start.spring.io to generate a basic project, follow the “Quick Start” example below, or read the reference documentation getting started guide. 快速开始如果你是一名Java程序员，你可以通过start.spring.io生成基本项目，按照下面的“快速开始”示例或者阅读参考文档的入门指南。 The recommended way to get started using spring-boot in your project is with a dependency management system – the snippet below can be copied and pasted into your build. Need help? See our getting started guides on building with Maven and Gradle. spring-boot在项目中开始使用的推荐方法是使用依赖关系管理系统 - 下面的代码段可以复制并粘贴到您的构建中。需要帮忙？请参阅我们使用Maven和 Gradle构建的入门指南。 Maven1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle123dependencies &#123; compile(&quot;org.springframework.boot:spring-boot-starter-web:1.5.1.RELEASE&quot;)&#125; 1hello/SampleController.java 123456789101112131415161718192021package hello;import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@Controller@EnableAutoConfigurationpublic class SampleController &#123; @RequestMapping(&quot;/&quot;) @ResponseBody String home() &#123; return &quot;Hello World!&quot;; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125; Spring Boot CLISpring Boot ships with a command line tool that can be used if you want to quickly prototype with Spring. It allows you to run Groovy scripts, which means that you have a familiar Java-like syntax, without so much boilerplate code. Follow the instructions in our main documentation if you want to install the Spring Boot CLI. Spring Boot 命令行工具Spring Boot附带一个命令行工具，如果你想快速使用Spring原型，可以使用它。它允许你运行Groovy脚本，这意味着你有一个熟悉的类似Java的语法，没有那么多的样板代码。如果要安装Spring Boot CLI，请按照我们的主要文档中的说明进行操作。","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://baiwenhui.com/tags/SpringBoot/"}]},{"title":"Java面试(一)","date":"2017-03-04T16:04:28.000Z","path":"2017/03/05/Java面试-一/","text":"Java基础抽象类和接口的区别？ 抽象类中可以包含抽象方法和非抽象方法，接口只能包含公开的抽象方法； 抽象类中的变量是各种类型的，而接口只能包含public abstract final 类型； 接口中不能含有静态代码块和静态方法，而抽象类中可以包含； 一个类只能继承一个抽象类，但是可以实现多个接口； 抽象类可以有构造方法，接口不能有； HashMap和HashTable的区别？ HashTable是基于陈旧的Dictionary的Map接口的实现，而HashMap是基于哈希表的Map接口的实现 从方法上看，HashMap去掉了HashTable的contains方法 HashTable是同步的（线程安全），而HashMap是线程不安全的，效率上HashMap更快 HashMap允许空键值，HashTable不允许，可以查看HashTable的实现源码： 12345678910111213141516171819202122232425...public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125;... HashMap的iterator迭代器执行快速失败机制，也就是说在迭代过程中修改集合结构，除非调用迭代器自身的remove方法，否则以其他任何方式的修改都将抛出并发修改异常。而Hashtable返回的Enumeration不是快速失败的。 Java中如何创建一个新线程？ 实现runable接口并重写run方法； 继承Thread类重写run方法； 实现Callable接口，重写call()方法；使用FutureTask类包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值；使用FutureTask对象作为Thread对象的target创建并启动线程，调用FutureTask对象的get()方法获得子线程执行结束后的返回值； 什么是AIDL？ AIDL全称Android Interface Definition Language（AndRoid接口描述语言）是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程跨界对象访问的目的.AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。 AIDL支持的数据类型有Stirng，list，map，All native java datatype 求计算1-2+3-4+5-6…的方法，n很大，考虑性能？1234567891011121314151617181920212223public static long fn(long n) &#123; if(n&lt;=0) &#123; //1-2+3-4+5-6 当n为负数时，结果肯定为负数,使用加法结合律得出当n为偶数时,结果为(1-2)+(3-4)...(-1)+(-1),规律 //当n为2时，结果为一个-1和，当n为4时，结果为2个-1的和,由此得出此结果的规律为(-1)*(n/2) //当n为奇数的时候，当n为1时，结果为1，当n为3时候,结果为2,当n为5时候,结果为3... //由此得出规律应该为：(-1)*(n/2)+n =-n/2+n 或者 (n+1)/2 //&gt;&gt;(右移) //操作数每右移一位，相当于该数除以2 System.out.println(&quot;error&quot;); return 0; &#125; if(0==n%2) return (n&gt;&gt;1)*(-1); else&#123; System.out.println(&quot;aaa&quot;); return (n&gt;&gt;1)*(-1)+n; //或者可以替换为(n+1)&gt;&gt;1; &#125; &#125; char类型的取值范围：0-216-1 Java中如何在线程中返回一个值？答案：可以让这个类去实现Callable接口，然后定义私有变量进行传递即可：如，1234567891011121314151617181920212223package com.pff;import java.util.concurrent.Callable;/** * Created by strongant on 16-6-16. */public class MutiThread implements Callable&lt;String&gt; &#123; private String str; private int count = 1; public MutiThread(String str) &#123; this.str = str; &#125; //需要实现的CallAble的Call方法 public String call() throws Exception &#123; for (int i = 0; i &lt; this.count; i++) &#123; System.out.println(&quot;Callable的call()方法打印:&quot; + this.str + &quot; &quot; + i); &#125; return this.str; &#125;&#125; 测试调用1234567891011121314151617181920212223242526272829303132package com.pff;import java.util.ArrayList;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * Created by strongant on 16-6-16. */public class CallableTest &#123; public static void main(String[] args) &#123; //创建一个线程池 ExecutorService exs = Executors.newCachedThreadPool(); ArrayList&lt;Future&lt;String&gt;&gt; al = new ArrayList&lt;&gt;(); al.add(exs.submit(new MutiThread(&quot;String0&quot;))); for (Future&lt;String&gt; fs : al) &#123; try &#123; System.out.println(fs.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; exs.shutdown(); /*第二种方式，使用FutureTask来接收线程的返回值 MutiThread task = new MutiThread(&quot;test&quot;); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(task); Thread thread = new Thread(futureTask); thread.start(); */ &#125;&#125; 具体流程就是实现Callable 泛型接口，然后线程类定义私有变量，重写call()方法，并且返回Callable接口声明的泛型类型值即可； 获取的时候使用Future泛型类去使用Future类的get()方法就可以获取到；","tags":[{"name":"Java面试","slug":"Java面试","permalink":"http://baiwenhui.com/tags/Java面试/"}]},{"title":"2017开工快乐","date":"2017-02-05T13:43:05.000Z","path":"2017/02/05/2017开工快乐/","text":"春节已经结束了，祝愿大家在新的一年多挣钱！在这里给大家分享一份简历模板：http://resume.f-tm.net/ 简历开源地址:https://github.com/googlerobot/resume","tags":[{"name":"随笔","slug":"随笔","permalink":"http://baiwenhui.com/tags/随笔/"}]},{"title":"春节回家","date":"2017-01-23T13:20:53.000Z","path":"2017/01/23/春节回家/","text":"对于刚过去不远的2016年，有欢乐，有辛酸，有失望，有快乐！还记得自己2016年年初的时候计划通过自己的努力买一台MakBook Pro（非正式工资的钱买），可到头来并没有完成我的这个愿望！ 远在他乡的我，随着年龄的增长，感到些许压抑、彷徨和不安，在新的2017年我决定奋力冲刺，早日实现自己的梦想！ 远在他乡，来到陌生的城市，看着天天上涨的房价，买房这件事情也只能想想。自己长大了，父母却老了，他们需要我们的照顾，在一线城市上几年班，攒个首付去二三线城市买一套房子然后打拼事业，这也是我的打算！乘着二三线城市的房价还没有大幅上涨，还是早下手为强！ 在一线城市上班，别人听起来工资很高，经常听到隔壁阿姨说：谁谁家的儿子在哪哪呢，一个月挣1W多呢，可是花销完，房租缴完，也剩不下多少钱了。要想拿到更多的薪水，就得从自身开始做起。我已经为自己制定好了2017年的计划，你呢？ 在这里，提前祝大家新年快乐！以上是我的一点生活感触，博客地址：http://baiwenhui.com，欢迎交流、分享：","tags":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://baiwenhui.com/tags/生活感悟/"}]},{"title":"rxjs翻译-rxjs介绍","date":"2017-01-22T13:26:40.000Z","path":"2017/01/22/rxjs翻译-rxjs介绍/","text":"介绍RxJS是一个基于可观察对象(Observable)序列，用于异步或者事件编程的库。它提供一个核心类型，Observable ，几个卫星类型（Observer, Schedulers, Subjects）以及一些由Array#extras (map, filter, reduce, every等)激发的，让异步事件可以以集合的方式被处理的运算子(Operators)。 可以将RxJS想象成是用于处理事件的Lodash. ReactiveX将Observer模式和Iterator模式和对集合进行函数式编程结合起来，从而满足了对事件序列进行管理的需求。 RxJS用于解决异步事件的管理问题，它的核心概念如下： Observable: 代表数据与事件的集合，这个集合可以被调用，从而可以生成数据和事件。 Observer: 回调函数的集合，用于获取想要数据。这些数据来自于Observable。 Subscription: 用于表示Observable的执行状态，主要用于执行的取消。 Operator: 函数式风格的纯函数，通过map, filter, concat, flatMap等操作对集合进行处理。 Subject: 与EventEmitter等价，唯一可以将一个值或者事件向个多个Observer进行广播的办法。 Schedulers: 一个中心化的、控制并发的分发器，允许我们可以在象setTimeout、requestAnimationFrame或者其它类似的计算中可以进行调整。 第一个例子通常你是这样注册事件的侦听器(listener)的。12var button = document.querySelector('button');button.addEventListener('click', () =&gt; console.log('Clicked!')); 使用RxJS的话，你要创建一个Observable来替换。 123var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .subscribe(() =&gt; console.log('Clicked!')); 纯粹(Purity)让RxJS强大的是它能完全通过函数来生成数值，这也就意味着可以减少代码出错的机会。 通常你会创建比较不纯粹的函数，在这样的函数里，其它的代码片段会让你的状态变的混乱。 123var count = 0;var button = document.querySelector('button');button.addEventListener('click', () =&gt; console.log(`Clicked $&#123;++count&#125; times`)); 而使用RxJS可以将你的状态进行隔离。 译者注： 指count不再需要定义在外面。 1234var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .scan(count =&gt; count + 1, 0) .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`)); 这里scan运算子的工作方式与reduce在数组里的工作方式是一样的。它从传给回调函数的值中获取值。返回的值将会作为下一次的传入值。 译者注：scan第二个参数0是初始值。对于上面的函数来说就可以用来侦听被点击的次数了，非常的方便。 流转（Flow）RxJS有一堆的运算子可以帮助你控制事件如何在你的可观察对象里流转。 下面是你在纯JavaScript下允许一分钟最多一次点击的代码： 12345678910var count = 0;var rate = 1000;var lastClick = Date.now() - rate;var button = document.querySelector('button');button.addEventListener('click', () =&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; console.log(`Clicked $&#123;++count&#125; times`); lastClick = Date.now(); &#125;&#125;); 使用RxJS后: 12345var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .throttleTime(1000) .scan(count =&gt; count + 1, 0) .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`)); 其实的流转控制运算子还有filter, delay, debounceTime, take, takeUntil, distinct, distinctUntilChanged等。 值(Values)你可以转化赋给你的观察者的值。 下面是你在纯JavaScript下添加当前鼠标的每个点击事件的x轴位置的代码： 1234567891011var count = 0;var rate = 1000;var lastClick = Date.now() - rate;var button = document.querySelector('button');button.addEventListener('click', (event) =&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; count += event.clientX; console.log(count) lastClick = Date.now(); &#125;&#125;); 使用RxJS后: 123456var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .throttleTime(1000) .map(event =&gt; event.clientX) .scan((count, clientX) =&gt; count + clientX, 0) .subscribe(count =&gt; console.log(count)); 另外几个用于生成值的运算子有pluck, pairwise,sample等。 译者注：这里map可以将事件里的值取出来，如果不进行map，clientX里的值就是事件本身。这里要注意的是每次变换，其实对象是发生变化的。subscribe一次之后就不能再subscribe了。","tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://baiwenhui.com/tags/rxjs/"}]},{"title":"修正browser-sync公众号文章的错误","date":"2017-01-21T14:30:29.000Z","path":"2017/01/21/修正browser-sync公众号文章的错误/","text":"首先说说声对不起，在上一篇的公众号文章：《放弃F5，拥抱browser-sync》中存在几个错误点。链接地址: https://mp.weixin.qq.com/s?__biz=MzAxMDgyOTgwOQ==&amp;mid=2247483709&amp;idx=1&amp;sn=9939c3029c12ef1f716111cd0c9e9ffc&amp;chksm=9b4b2ba3ac3ca2b5dea5496d6f9d87d7a0218ed85e4f807d4da2374957dd1b64cea234d5074c&amp;mpshare=1&amp;scene=1&amp;srcid=0228DCwqHbO5bJNRzdNcoQaJ&amp;key=1ffbac7579ea006ba638f1c527ceb6fccc5cd60675bb72cb4ac4e1669f8844ac48f5c811613c0700f5b5a5d0758631cddccd09a62852836bbe7ea0a2f3b6519205a05d50a53e595fa3c414a39a8f507f&amp;ascene=0&amp;uin=MTkwMTU1MzgyMw%3D%3D&amp;devicetype=iMac+Macmini7%2C1+OSX+OSX+10.12.3+build(16D32)&amp;version=12020010&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=iTAw5XKKAiEh5rRG8zKg5HPSatL3GYf2%2FVDBxyBOTnbVmCeOf%2FgW%2FmhS5DctS64z 几个错误点修改如下： 文章中的：……更重要的是 Browsersync可以同时在PC、平板、手机等设备下进项调试…将“进项调试”修改为“进行调试”2. 最后的代码有一个目录错误，因为我的粗心，给大家带来的不变，请见谅！在以后的文章中我会更加小心发表文章，力求保证没有错误！1234567891011121314151617181920212223242526272829var gulp = require(&apos;gulp&apos;);var browserSync = require(&apos;browser-sync&apos;).create();var browserify = require(&apos;gulp-browserify&apos;);var sass = require(&apos;gulp-sass&apos;);var uglify = require(&apos;gulp-uglify&apos;);// Compile sass into CSS &amp; auto-inject into browsersgulp.task(&apos;sass&apos;, function() &#123; return gulp.src(&quot;app/scss/*.scss&quot;) .pipe(sass()) .pipe(gulp.dest(&quot;dist/css&quot;)) .pipe(browserSync.stream());&#125;);// process JS files and return the stream.gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;app/js/*.js&apos;) .pipe(browserify()) .pipe(uglify()) .pipe(gulp.dest(&apos;dist/js&apos;));&#125;);// Static Server + watching scss/js/html filesgulp.task(&apos;serve&apos;, [&apos;sass&apos;,&apos;js&apos;], function() &#123; browserSync.init(&#123; server: &quot;./app&quot; &#125;); gulp.watch(&quot;app/scss/*.scss&quot;, [&apos;sass&apos;]); gulp.watch(&quot;app/js/*.js&quot;, [&apos;js&apos;]); gulp.watch(&quot;app/*.html&quot;).on(&apos;change&apos;, browserSync.reload);&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 修改为：1234567891011121314151617181920212223242526272829var gulp = require(&apos;gulp&apos;);var browserSync = require(&apos;browser-sync&apos;).create();var browserify = require(&apos;gulp-browserify&apos;);var sass = require(&apos;gulp-sass&apos;);var uglify = require(&apos;gulp-uglify&apos;);// Compile sass into CSS &amp; auto-inject into browsersgulp.task(&apos;sass&apos;, function() &#123; return gulp.src(&quot;app/scss/*.scss&quot;) .pipe(sass()) .pipe(gulp.dest(&quot;.app/dist/css&quot;)) .pipe(browserSync.stream());&#125;);// process JS files and return the stream.gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;app/js/*.js&apos;) .pipe(browserify()) .pipe(uglify()) .pipe(gulp.dest(&apos;.app/dist/js&apos;));&#125;);// Static Server + watching scss/js/html filesgulp.task(&apos;serve&apos;, [&apos;sass&apos;,&apos;js&apos;], function() &#123; browserSync.init(&#123; server: &quot;./app&quot; &#125;); gulp.watch(&quot;app/scss/*.scss&quot;, [&apos;sass&apos;]); gulp.watch(&quot;app/js/*.js&quot;, [&apos;js&apos;]); gulp.watch(&quot;app/*.html&quot;).on(&apos;change&apos;, browserSync.reload);&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 参照对比原文地址： https://mp.weixin.qq.com/s?__biz=MzAxMDgyOTgwOQ==&amp;mid=2247483709&amp;idx=1&amp;sn=9939c3029c12ef1f716111cd0c9e9ffc&amp;chksm=9b4b2ba3ac3ca2b5dea5496d6f9d87d7a0218ed85e4f807d4da2374957dd1b64cea234d5074c&amp;mpshare=1&amp;scene=1&amp;srcid=0228DCwqHbO5bJNRzdNcoQaJ&amp;key=1ffbac7579ea006ba638f1c527ceb6fccc5cd60675bb72cb4ac4e1669f8844ac48f5c811613c0700f5b5a5d0758631cddccd09a62852836bbe7ea0a2f3b6519205a05d50a53e595fa3c414a39a8f507f&amp;ascene=0&amp;uin=MTkwMTU1MzgyMw%3D%3D&amp;devicetype=iMac+Macmini7%2C1+OSX+OSX+10.12.3+build(16D32)&amp;version=12020010&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=iTAw5XKKAiEh5rRG8zKg5HPSatL3GYf2%2FVDBxyBOTnbVmCeOf%2FgW%2FmhS5DctS64z 目前内容已经修改！欢迎反馈，欢迎交流：","tags":[]},{"title":"hexo搭建成功","date":"2017-01-19T15:20:52.000Z","path":"2017/01/19/hexo搭建成功/","text":"终于折腾完了，搭建好我的hexo，的确挺方便的！感谢前人的贡献！","tags":[]}]